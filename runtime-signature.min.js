/** @license MIT (c) 2018 Laurent Payot  */
var AnyType,Tuple,TypedMap,TypedObject,TypedSet,_Etc,_Tuple,_TypedMap,_TypedObject,_TypedSet,error,etc,fn,isAnyType,isType,maybe,promised,typeName,typeOf;error=function(e){throw new Error(function(){switch(e[0]){case"!":return`Invalid type syntax: ${e.slice(1)}`;case"@":return`Invalid signature: ${e.slice(1)}`;default:return`Type error: ${e}`}}())},_Tuple=class{constructor(...e){if(this.types=e,arguments.length<2&&error("!Tuple must have at least two type arguments."),this.types.every(function(e){return isAnyType(e)}))return Array}},_TypedObject=class{constructor(e){if(this.type=e,1!==arguments.length&&error("!TypedObject must have exactly one type argument."),isAnyType(this.type))return Object}},_TypedSet=class{constructor(e){if(this.type=e,1!==arguments.length&&error("!TypedSet must have exactly one type argument."),isAnyType(this.type))return Set}},_TypedMap=function(){class e{constructor(e,t){switch(arguments.length){case 0:error("!TypedMap must have at least one type argument.");break;case 1:if(isAnyType(e))return Map;this.valuesType=e;break;case 2:if(isAnyType(e)&&isAnyType(t))return Map;[this.keysType,this.valuesType]=[e,t];break;default:error("!TypedMap can not have more than two type arguments.")}}}return e.prototype.keysType=[],e.prototype.valuesType=[],e}.call(this),_Etc=class{constructor(e=[]){this.type=e,arguments.length>1&&error("!'etc' can not have more than one type argument.")}},isAnyType=function(e){return e===AnyType||Array.isArray(e)&&0===e.length},AnyType=function(){return arguments.length?error("!'AnyType' can not have a type argument."):[]},maybe=function(...e){return arguments.length||error("!'maybe' must have at least one type argument."),e.some(function(e){return isAnyType(e)})?[]:[void 0,null].concat(e)},promised=function(e){return 1!==arguments.length&&error("!'promised' must have exactly one type argument."),isAnyType(e)?Promise:Promise.resolve(e)},Tuple=function(...e){return new _Tuple(...e)},TypedObject=function(...e){return new _TypedObject(...e)},TypedSet=function(...e){return new _TypedSet(...e)},TypedMap=function(...e){return new _TypedMap(...e)},etc=function(...e){return new _Etc(...e)},typeOf=function(e){return void 0===e||null===e?""+e:e.constructor.name},isType=function(e,t){var r,n,y,s,u,o,p,a,i,c,l;if(Array.isArray(t))switch(t.length){case 0:return!0;case 1:return!!Array.isArray(e)&&(!!isAnyType(t[0])||e.every(function(e){return isType(e,t[0])}));default:return t.some(function(t){return isType(e,t)})}else switch(null!=t?t.constructor:void 0){case void 0:case String:case Number:case Boolean:return e===t;case Function:switch(t){case AnyType:return!0;case promised:case maybe:case TypedObject:case TypedSet:case TypedMap:return error(`!'${t.name}' can not be used directly as a function.`);case etc:return error("!'etc' can not be used in types.");default:return(null!=e?e.constructor:void 0)===t}break;case Object:if((null!=e?e.constructor:void 0)!==Object)return!1;if(!Object.keys(t).length)return!Object.keys(e).length;for(r in t)if(i=t[r],!isType(e[r],i))return!1;return!0;case _Tuple:return a=t.types,!(!Array.isArray(e)||e.length!==a.length)&&e.every(function(e,t){return isType(e,a[t])});case _TypedObject:return(null!=e?e.constructor:void 0)===Object&&(p=t.type,!!isAnyType(p)||Object.values(e).every(function(e){return isType(e,p)}));case _TypedSet:return(null!=e?e.constructor:void 0)===Set&&(p=t.type,!!isAnyType(p)||("undefined"!==(u=typeOf(p))&&"null"!==u&&"String"!==u&&"Number"!==u&&"Boolean"!==u||error(`!Typed Set type can not be a literal of type '${p}'.`),[...e].every(function(e){return isType(e,p)})));case _TypedMap:if((null!=e?e.constructor:void 0)!==Map)return!1;switch(({keysType:y,valuesType:l}=t),!1){case!(isAnyType(y)&&isAnyType(l)):return!0;case!isAnyType(y):return Array.from(e.values()).every(function(e){return isType(e,l)});case!isAnyType(l):return Array.from(e.keys()).every(function(e){return isType(e,y)});default:return n=Array.from(e.keys()),c=Array.from(e.values()),n.every(function(e){return isType(e,y)})&&c.every(function(e){return isType(e,l)})}break;case _Etc:return error("!'etc' can not be used in types.");default:return s=(o=t.constructor)===Set||o===Map?"the provided Typed":"",error(`!Type can not be an instance of ${typeOf(t)}. Use ${s}${typeOf(t)} as type instead.`)}},typeName=function(e){var t;if(isAnyType(e))return"any type";switch(null!=e?e.constructor:void 0){case void 0:return typeOf(e);case Array:return 1===e.length?`array of '${typeName(e[0])}'`:function(){var r,n,y;for(y=[],r=0,n=e.length;r<n;r++)t=e[r],y.push(typeName(t));return y}().join(" or ");case Function:return e.name;case Object:return"custom type object";case _Tuple:return`tuple of ${e.types.length} elements '${function(){var r,n,y,s;for(s=[],r=0,n=(y=e.types).length;r<n;r++)t=y[r],s.push(typeName(t));return s}().join(", ")}'`;default:return`literal ${typeOf(e)} '${e}'`}},fn=function(e,t,r){return Array.isArray(e)||error("@Array of arguments types is missing."),(null!=t?t.constructor:void 0)!==Function||t.name||error("@Result type is missing."),(null!=r?r.constructor:void 0)!==Function&&error("@Function to wrap is missing."),function(...n){var y,s,u,o,p,a,i,c,l,T,f,d;for(l=!1,s=o=0,p=e.length;o<p;s=++o)if((d=e[s])===etc||(null!=d?d.constructor:void 0)===_Etc){if(s+1<e.length&&error("@Rest type must be the last of the arguments types."),l=!0,f=d===etc?[]:d.type,!isAnyType(f))for(u=i=0,a=(c=n.slice(s)).length;i<a;u=++i)y=c[u],isType(y,f)||error(`Argument number ${s+u+1} (${y}) should be of type ${typeName(f)} instead of ${typeOf(y)}.`)}else isAnyType(d)||(void 0===n[s]?isType(void 0,d)||error(`Missing required argument number ${s+1}.`):isType(n[s],d)||error(`Argument number ${s+1} (${n[s]}) should be of type ${typeName(d)} instead of ${typeOf(n[s])}.`));return n.length>e.length&&!l&&error("Too many arguments provided."),(null!=t?t.constructor:void 0)===Promise?t.then(function(e){var t;return(null!=(t=r(...n))?t.constructor:void 0)!==Promise&&error("Function should return a promise."),t.then(function(t){return isType(t,e)||error(`Promise result (${t}) should be of type ${typeName(e)} instead of ${typeOf(t)}.`),t})}):(T=r(...n),isType(T,t)||error(`Result (${T}) should be of type ${typeName(t)} instead of ${typeOf(T)}.`),T)}},module.exports={typeOf:typeOf,isType:isType,fn:fn,maybe:maybe,AnyType:AnyType,promised:promised,etc:etc,Tuple:Tuple,TypedObject:TypedObject,TypedSet:TypedSet,TypedMap:TypedMap};