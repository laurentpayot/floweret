/** @license MIT (c) 2018 Laurent Payot  */
var Tuple,TypedMap,TypedObject,TypedSet,_Etc,_Tuple,_TypedMap,_TypedObject,_TypedSet,anyType,error,etc,fn,isAnyType,isType,maybe,promised,typeName,typeOf;error=function(e){throw new Error(function(){switch(e[0]){case"!":return`Invalid type syntax: ${e.slice(1)}`;case"@":return`Invalid signature: ${e.slice(1)}`;default:return`Type error: ${e}`}}())},_Tuple=class{constructor(e){if(this.types=e,arguments.length<2&&error("!Tuple must have at least two type arguments."),this.types.every(function(e){return isAnyType(e)}))return Array}},_TypedObject=class{constructor(e){if(this.type=e,1!==arguments.length&&error("!TypedObject must have exactly one type argument."),isAnyType(this.type))return Object}},_TypedSet=class{constructor(e){if(this.type=e,1!==arguments.length&&error("!TypedSet must have exactly one type argument."),isAnyType(this.type))return Set}},_TypedMap=function(){class e{constructor(e,r){switch(arguments.length){case 0:error("!TypedMap must have at least one type argument.");break;case 1:if(isAnyType(e))return Map;this.valuesType=e;break;case 2:if(isAnyType(e)&&isAnyType(r))return Map;[this.keysType,this.valuesType]=[e,r];break;default:error("!TypedMap can not have more than two type arguments.")}}}return e.prototype.keysType=[],e.prototype.valuesType=[],e}.call(this),_Etc=class{constructor(e=[]){this.type=e,arguments.length>1&&error("!'etc' can not have more than one type argument.")}},isAnyType=function(e){return e===anyType||Array.isArray(e)&&0===e.length},anyType=function(){return arguments.length?error("!'anyType' can not have a type argument."):[]},maybe=function(...e){return arguments.length||error("!'maybe' must have at least one type argument."),e.some(function(e){return isAnyType(e)})?[]:[void 0,null].concat(e)},promised=function(e){return 1!==arguments.length&&error("!'promised' must have exactly one type argument."),isAnyType(e)?Promise:Promise.resolve(e)},Tuple=function(...e){return new _Tuple(...e)},TypedObject=function(...e){return new _TypedObject(...e)},TypedSet=function(...e){return new _TypedSet(...e)},TypedMap=function(...e){return new _TypedMap(...e)},etc=function(...e){return new _Etc(...e)},typeOf=function(e){return void 0===e||null===e?""+e:e.constructor.name},isType=function(e,r){var t,n,y,s,o,u,a,p,i,c,l;if(Array.isArray(r))switch(r.length){case 0:return!0;case 1:return!!Array.isArray(e)&&(!!isAnyType(r[0])||e.every(function(e){return isType(e,r[0])}));default:return r.some(function(r){return isType(e,r)})}else switch(null!=r?r.constructor:void 0){case void 0:case String:case Number:case Boolean:return e===r;case Function:switch(r){case anyType:return!0;case promised:case maybe:case TypedObject:case TypedSet:case TypedMap:return error(`!'${r.name}' can not be used directly as a function.`);case etc:return error("!'etc' can not be used in types.");default:return(null!=e?e.constructor:void 0)===r}break;case Object:if((null!=e?e.constructor:void 0)!==Object)return!1;if(!Object.keys(r).length)return!Object.keys(e).length;for(t in r)if(i=r[t],!isType(e[t],i))return!1;return!0;case _Tuple:return p=r.types,!((null!=e?e.constructor:void 0)!==Array||!(e.length=p.length))&&e.every(function(e,r){return isType(e,p[r])});case _TypedObject:return(null!=e?e.constructor:void 0)===Object&&(a=r.type,!!isAnyType(a)||Object.values(e).every(function(e){return isType(e,a)}));case _TypedSet:return(null!=e?e.constructor:void 0)===Set&&(a=r.type,!!isAnyType(a)||("undefined"!==(o=typeOf(a))&&"null"!==o&&"String"!==o&&"Number"!==o&&"Boolean"!==o||error(`!Typed Set type can not be a literal of type '${a}'.`),[...e].every(function(e){return isType(e,a)})));case _TypedMap:if((null!=e?e.constructor:void 0)!==Map)return!1;switch(({keysType:y,valuesType:l}=r),!1){case!(isAnyType(y)&&isAnyType(l)):return!0;case!isAnyType(y):return Array.from(e.values()).every(function(e){return isType(e,l)});case!isAnyType(l):return Array.from(e.keys()).every(function(e){return isType(e,y)});default:return n=Array.from(e.keys()),c=Array.from(e.values()),n.every(function(e){return isType(e,y)})&&c.every(function(e){return isType(e,l)})}break;case _Etc:return error("!'etc' can not be used in types.");default:return s=(u=r.constructor)===Set||u===Map?"the provided Typed":"",error(`!Type can not be an instance of ${typeOf(r)}. Use ${s}${typeOf(r)} as type instead.`)}},typeName=function(e){var r;if(isAnyType(e))return"any type";switch(null!=e?e.constructor:void 0){case void 0:return typeOf(e);case Array:return 1===e.length?`array of '${typeName(e[0])}'`:function(){var t,n,y;for(y=[],t=0,n=e.length;t<n;t++)r=e[t],y.push(typeName(r));return y}().join(" or ");case Function:return e.name;case Object:return"custom type object";default:return`literal ${typeOf(e)} '${e}'`}},fn=function(e,r,t){return Array.isArray(e)||error("@Array of arguments types is missing."),(null!=r?r.constructor:void 0)!==Function||r.name||error("@Result type is missing."),(null!=t?t.constructor:void 0)!==Function&&error("@Function to wrap is missing."),function(...n){var y,s,o,u,a,p,i,c,l,T,f,d;for(l=!1,s=u=0,a=e.length;u<a;s=++u)if((d=e[s])===etc||(null!=d?d.constructor:void 0)===_Etc){if(s+1<e.length&&error("@Rest type must be the last of the arguments types."),l=!0,f=d===etc?[]:d.type,!isAnyType(f))for(o=i=0,p=(c=n.slice(s)).length;i<p;o=++i)y=c[o],isType(y,f)||error(`Argument number ${s+o+1} (${y}) should be of type ${typeName(f)} instead of ${typeOf(y)}.`)}else isAnyType(d)||(void 0===n[s]?isType(void 0,d)||error(`Missing required argument number ${s+1}.`):isType(n[s],d)||error(`Argument number ${s+1} (${n[s]}) should be of type ${typeName(d)} instead of ${typeOf(n[s])}.`));return n.length>e.length&&!l&&error("Too many arguments provided."),(null!=r?r.constructor:void 0)===Promise?r.then(function(e){var r;return(null!=(r=t(...n))?r.constructor:void 0)!==Promise&&error("Function should return a promise."),r.then(function(r){return isType(r,e)||error(`Promise result (${r}) should be of type ${typeName(e)} instead of ${typeOf(r)}.`),r})}):(T=t(...n),isType(T,r)||error(`Result (${T}) should be of type ${typeName(r)} instead of ${typeOf(T)}.`),T)}},module.exports={typeOf:typeOf,isType:isType,fn:fn,maybe:maybe,anyType:anyType,promised:promised,etc:etc,Tuple:Tuple,TypedObject:TypedObject,TypedSet:TypedSet,TypedMap:TypedMap};