/** @license MIT (c) 2018 Laurent Payot  */
var AnyType,Tuple,Type,TypedMap,TypedObject,TypedSet,_Etc,_Tuple,_TypedMap,_TypedObject,_TypedSet,badPath,error,etc,fn,isAnyType,isType,maybe,promised,shouldBe,typeName,typeOf,splice=[].splice;error=function(e){throw new Error(function(){switch(e[0]){case"!":return`Invalid type syntax: ${e.slice(1)}`;case"@":return`Invalid signature: ${e.slice(1)}`;default:return`Type error: ${e}`}}())},Type=class{},_Tuple=class extends Type{constructor(...e){if(super(),this.types=e,arguments.length<2&&error("!Tuple must have at least two type arguments."),this.types.every(function(e){return isAnyType(e)}))return Array}validate(e){return!(!Array.isArray(e)||e.length!==this.types.length)&&e.every((e,t)=>isType(e,this.types[t]))}},Tuple=function(...e){return new _Tuple(...e)},_TypedObject=class extends Type{constructor(e){if(super(),this.type=e,1!==arguments.length&&error("!TypedObject must have exactly one type argument."),isAnyType(this.type))return Object}validate(e){return(null!=e?e.constructor:void 0)===Object&&(!!isAnyType(this.type)||Object.values(e).every(e=>isType(e,this.type)))}},TypedObject=function(...e){return new _TypedObject(...e)},_TypedSet=class extends Type{constructor(e){if(super(),this.type=e,1!==arguments.length&&error("!TypedSet must have exactly one type argument."),isAnyType(this.type))return Set}validate(e){var t,r;return(null!=e?e.constructor:void 0)===Set&&(!!isAnyType(this.type)||(void 0!==(t=null!=(r=this.type)?r.constructor:void 0)&&t!==String&&t!==Number&&t!==Boolean||error(`!Typed Set type can not be a literal of type '${this.type}'.`),[...e].every(e=>isType(e,this.type))))}},TypedSet=function(...e){return new _TypedSet(...e)},_TypedMap=function(){class e extends Type{constructor(e,t){switch(super(),arguments.length){case 0:error("!TypedMap must have at least one type argument.");break;case 1:if(isAnyType(e))return Map;this.valuesType=e;break;case 2:if(isAnyType(e)&&isAnyType(t))return Map;[this.keysType,this.valuesType]=[e,t];break;default:error("!TypedMap can not have more than two type arguments.")}}validate(e){var t,r;if((null!=e?e.constructor:void 0)!==Map)return!1;switch(!1){case!(isAnyType(this.keysType)&&isAnyType(this.valuesType)):return!0;case!isAnyType(this.keysType):return Array.from(e.values()).every(e=>isType(e,this.valuesType));case!isAnyType(this.valuesType):return Array.from(e.keys()).every(e=>isType(e,this.keysType));default:return t=Array.from(e.keys()),r=Array.from(e.values()),t.every(e=>isType(e,this.keysType))&&r.every(e=>isType(e,this.valuesType))}}}return e.prototype.keysType=[],e.prototype.valuesType=[],e}.call(this),TypedMap=function(...e){return new _TypedMap(...e)},isAnyType=function(e){return e===AnyType||Array.isArray(e)&&0===e.length},AnyType=function(){return arguments.length?error("!'AnyType' can not have a type argument."):[]},maybe=function(...e){return arguments.length||error("!'maybe' must have at least one type argument."),e.some(function(e){return isAnyType(e)})?[]:[void 0,null].concat(e)},promised=function(e){return 1!==arguments.length&&error("!'promised' must have exactly one type argument."),isAnyType(e)?Promise:Promise.resolve(e)},_Etc=class{constructor(e=[]){this.type=e,arguments.length>1&&error("!'etc' can not have more than one type argument.")}},etc=function(...e){return new _Etc(...e)},typeOf=function(e){return void 0===e||null===e?""+e:e.constructor.name},isType=function(e,t){var r,n,s,y;if(Array.isArray(t))switch(t.length){case 0:return!0;case 1:return!!Array.isArray(e)&&(!!isAnyType(t[0])||e.every(function(e){return isType(e,t[0])}));default:return t.some(function(t){return isType(e,t)})}else switch(null!=t?t.constructor:void 0){case void 0:case String:case Number:case Boolean:return e===t;case Function:switch(t){case AnyType:return!0;case promised:case maybe:case TypedObject:case TypedSet:case TypedMap:return error(`!'${t.name}' can not be used directly as a function.`);case etc:return error("!'etc' can not be used in types.");default:return(null!=e?e.constructor:void 0)===t}break;case Object:if((null!=e?e.constructor:void 0)!==Object)return!1;for(r in t)if(y=t[r],!isType(e[r],y))return!1;return!0;case _Etc:return error("!'etc' can not be used in types.");default:return t instanceof Type?t.validate(e):(n=(s=t.constructor)===Set||s===Map?"the provided Typed":"",error(`!Type can not be an instance of ${typeOf(t)}. Use ${n}${typeOf(t)} as type instead.`))}},badPath=function(e,t){var r,n,s;for(r in t)if(s=t[r],!isType(e[r],s))return[r].concat((null!=(n=e[r])?n.constructor:void 0)===Object?badPath(e[r],t[r]):[e[r],t[r]])},typeName=function(e){var t;if(isAnyType(e))return"any type";switch(null!=e?e.constructor:void 0){case void 0:return typeOf(e);case Array:return 1===e.length?`array of '${typeName(e[0])}'`:function(){var r,n,s;for(s=[],r=0,n=e.length;r<n;r++)t=e[r],s.push(typeName(t));return s}().join(" or ");case Function:return e.name;case Object:return"custom type object";case _Tuple:return`tuple of ${e.types.length} elements '${function(){var r,n,s,y;for(y=[],r=0,n=(s=e.types).length;r<n;r++)t=s[r],y.push(typeName(t));return y}().join(", ")}'`;default:return`literal ${typeOf(e)} '${e}'`}},shouldBe=function(e,t){var r,n,s,y;return(null!=e?e.constructor:void 0)===Object?(y=badPath(e,t),[...r]=y,[s,n]=splice.call(r,-2),`should be an object with key '${r.join(".")}' of type ${typeName(n)} instead of ${typeOf(s)}`):`(${e}) should be of type ${typeName(t)} instead of ${typeOf(e)}`},fn=function(e,t,r){return Array.isArray(e)||error("@Array of arguments types is missing."),(null!=t?t.constructor:void 0)!==Function||t.name||error("@Result type is missing."),(null!=r?r.constructor:void 0)!==Function&&error("@Function to wrap is missing."),function(...n){var s,y,o,u,i,a,p,c,l,T,d,h;for(l=!1,y=u=0,i=e.length;u<i;y=++u)if((h=e[y])===etc||(null!=h?h.constructor:void 0)===_Etc){if(y+1<e.length&&error("@Rest type must be the last of the arguments types."),l=!0,d=h===etc?[]:h.type,!isAnyType(d))for(o=p=0,a=(c=n.slice(y)).length;p<a;o=++p)s=c[o],isType(s,d)||error(`Argument number ${y+o+1} ${shouldBe(s,d)}.`)}else isAnyType(h)||(void 0===n[y]?isType(void 0,h)||error(`Missing required argument number ${y+1}.`):isType(n[y],h)||error(`Argument number ${y+1} ${shouldBe(n[y],h)}.`));return n.length>e.length&&!l&&error("Too many arguments provided."),(null!=t?t.constructor:void 0)===Promise?t.then(function(e){var t;return(null!=(t=r(...n))?t.constructor:void 0)!==Promise&&error("Function should return a promise."),t.then(function(t){return isType(t,e)||error(`Promise result ${shouldBe(t,e)}.`),t})}):(T=r(...n),isType(T,t)||error(`Result ${shouldBe(T,t)}.`),T)}},module.exports={typeOf:typeOf,isType:isType,fn:fn,maybe:maybe,AnyType:AnyType,promised:promised,etc:etc,Tuple:Tuple,TypedObject:TypedObject,TypedSet:TypedSet,TypedMap:TypedMap};