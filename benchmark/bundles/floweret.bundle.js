(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.myBundle = factory());
}(this, (function () { 'use strict';

  // Generated by CoffeeScript 2.3.2
  var CustomType, InvalidType, s;

  InvalidType = class InvalidType extends Error {};

  s = function(n) {
    if (n === 1) {
      return '';
    } else {
      return 's';
    }
  };

  CustomType = class CustomType {
    // static methods
    static error(msg) {
      throw new InvalidType(msg);
    }

    static warn(msg) {
      if ((typeof process !== "undefined" && process !== null ? process.env.NODE_ENV : void 0) !== 'production') {
        return console.warn("Floweret type:", msg);
      }
    }

    static createHelper(childClass) {
      var h;
      h = function() {
        return new childClass(...arguments);
      };
      h.rootClass = CustomType;
      return h;
    }

    constructor(args, min, max) {
      var l, name;
      if (this.constructor === CustomType) {
        CustomType.error("Abstract class 'CustomType' cannot be instantiated directly.");
      }
      if (!arguments.length) {
        CustomType.error("Super needs child type arguments as its first argument.");
      }
      l = args.length;
      name = this.helperName || this.constructor.name;
      switch (false) {
        case max !== void 0:
          if (min && l < min) {
            CustomType.error(`'${name}' must have at least ${min} argument${s(min)}.`);
          }
          break;
        case min !== max:
          if (min === 0 && l) {
            CustomType.error(`'${name}' cannot have any arguments.`);
          }
          if (l !== min) {
            CustomType.error(`'${name}' must have exactly ${min} argument${s(min)}.`);
          }
          break;
        default:
          if (l > max) {
            CustomType.error(`'${name}' must have at most ${max} argument${s(max)}.`);
          }
          if (l < min) {
            CustomType.error(`'${name}' must have at least ${min} argument${s(min)}.`);
          }
      }
    }

    validate() {
      return false; // false if child class validate() missing
    }

    getTypeName() {
      return this.constructor.name;
    }

  };

  var CustomType_1 = CustomType;

  // Generated by CoffeeScript 2.3.2
  var AnyType, CustomType$1;

  CustomType$1 = CustomType_1;

  AnyType = class AnyType extends CustomType$1 {
    constructor() {
      super(arguments, 0, 0); // no arguments
    }

    validate(val) {
      return true;
    }

    getTypeName() {
      return "any type";
    }

  };

  var AnyType_1 = CustomType$1.createHelper(AnyType);

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  // Generated by CoffeeScript 2.3.2
  var CustomType$2, Etc;

  CustomType$2 = CustomType_1;

  Etc = (function() {
    class Etc extends CustomType$2 {
      constructor(type = []) {
        super(arguments, 0, 1);
        this.type = type;
      }

      validate() {
        return CustomType$2.error(`'${this.helperName}' cannot be used in types.`);
      }

    }
    Etc.prototype.helperName = "etc";

    return Etc;

  }).call(commonjsGlobal);

  var etc = CustomType$2.createHelper(Etc);

  // Generated by CoffeeScript 2.3.2
    /** Floweret @license MIT (c) 2018 Laurent Payot */
  var AnyType$1, AnyTypeHelper, CustomType$3, Etc$1, EtcHelper, InvalidSignature, TypeMismatch, badPath, error, fn, getTypeName, isAnyType, isType, shouldBe, typeOf,
    splice = [].splice;

  CustomType$3 = CustomType_1;

  AnyTypeHelper = AnyType_1;

  EtcHelper = etc;

  InvalidSignature = class InvalidSignature extends Error {};

  TypeMismatch = class TypeMismatch extends Error {};

  error = function(msg) {
    if (msg[0] === '@') {
      throw new InvalidSignature(msg.slice(1));
    } else {
      throw new TypeMismatch(msg);
    }
  };

  Etc$1 = EtcHelper().constructor;

  AnyType$1 = AnyTypeHelper().constructor;

  isAnyType = function(o) {
    return Array.isArray(o) && o.length === 0 || o === AnyTypeHelper || o instanceof AnyType$1;
  };

  // typeOf([]) is 'Array', whereas typeof [] is 'object'. Same for null, NaN, Promise etc.
  typeOf = function(val) {
    if ((val === (void 0) || val === null) || Number.isNaN(val)) {
      return '' + val;
    } else {
      return val.constructor.name;
    }
  };

  // check that a value is of a given type or of any (undefined) type, e.g.: isType("foo", String)
  isType = function(val, type) {
    var k, prefix, ref, v;
    if (Array.isArray(type)) { // NB: special Array case http://web.mit.edu/jwalden/www/isArray.html
      switch (type.length) {
        case 0:
          return true; // any type: `[]`
        case 1:
          switch (false) {
            case !!Array.isArray(val):
              return false;
            case !isAnyType(type[0]):
              return true;
            case !!Object.values(type).length:
              return val.length === 1; // array of one empty value: sized array `Array(1)`
            default:
              return val.every(function(e) {
                return isType(e, type[0]);
              });
          }
          break;
        default:
          // NB: checking two first values instead of `Object.values(type).length` for performance reasons
          if (type[0] === void 0 && type[1] === void 0) { // array of empty values: sized array, e.g.: `Array(1000)`)
            return Array.isArray(val) && val.length === type.length;
          } else {
            return type.some(function(t) {
              return isType(val, t); // union of types, e.g.: `[Object, null]`
            });
          }
      }
    } else {
      switch (type != null ? type.constructor : void 0) {
        case void 0:
        case String:
        case Number:
        case Boolean: // literal type or undefined or null or NaN (NaN.constuctor is Number!)
          if (Number.isNaN(type)) {
            return Number.isNaN(val);
          } else {
            return val === type;
          }
          break;
        case Function:
          if (type.rootClass === CustomType$3) { // type is a helper
            return type().validate(val); // using default helper arguments
  // constructors of native types (Number, String, Object, Array, Promise, Set, Mapâ€¦) and custom classes
          } else {
            return !Number.isNaN(val) && (val != null ? val.constructor : void 0) === type; // NB: NaN.constuctor is Number
          }
          break;
        case Object: // Object type, e.g.: `{id: Number, name: {firstName: String, lastName: String}}`
          if ((val != null ? val.constructor : void 0) !== Object) {
            return false;
          }
          for (k in type) {
            v = type[k];
            if (!isType(val[k], v)) {
              return false;
            }
          }
          return true;
        case RegExp:
          return (val != null ? val.constructor : void 0) === String && type.test(val);
        default:
          if (type instanceof CustomType$3) {
            return type.validate(val);
          } else {
            prefix = (ref = type.constructor) === Set || ref === Map ? 'the provided Typed' : '';
            return CustomType$3.error(`Type can not be an instance of ${typeOf(type)}. Use ${prefix}${typeOf(type)} as type instead.`);
          }
      }
    }
  };

  // returns a list of keys path to where the type do not match + value not maching + type not matching
  badPath = function(obj, typeObj) {
    var k, ref, t;
    for (k in typeObj) {
      t = typeObj[k];
      if (!isType(obj[k], t)) {
        return [k].concat(((ref = obj[k]) != null ? ref.constructor : void 0) === Object ? badPath(obj[k], typeObj[k]) : [obj[k], typeObj[k]]);
      }
    }
  };

  // returns the type name for signature error messages (supposing type is always correct)
  getTypeName = function(type) {
    var t;
    switch (type != null ? type.constructor : void 0) {
      case void 0:
        return typeOf(type);
      case Array:
        switch (type.length) {
          case 0:
            return "any type";
          case 1:
            return `array of '${getTypeName(type[0])}'`;
          default:
            return ((function() {
              var l, len, results;
              results = [];
              for (l = 0, len = type.length; l < len; l++) {
                t = type[l];
                results.push(getTypeName(t));
              }
              return results;
            })()).join(" or ");
        }
        break;
      case Function:
        if (type.rootClass === CustomType$3) {
          return type().getTypeName();
        } else {
          return type.name;
        }
        break;
      case Object:
        return "object type";
      default:
        if (type instanceof CustomType$3) {
          return type.getTypeName();
        } else {
          return `literal ${typeOf(type)} ${(typeof type === 'string' ? '"' + type + '"' : type)}`;
        }
    }
  };

  // type error message comparison part helper
  shouldBe = function(val, type, promised = false) {
    var apo, bp, bt, bv, ref;
    apo = promised ? "a promise of " : '';
    switch (false) {
      case (val != null ? val.constructor : void 0) !== Object:
        ref = badPath(val, type), [...bp] = ref, [bv, bt] = splice.call(bp, -2);
        return `should be ${apo}an object with key '${bp.join('.')}' of type '${getTypeName(bt)}' instead of ${typeOf(bv)}`;
      default:
        return `(${val}) should be ${apo || 'of type '}'${getTypeName(type)}' instead of ${typeOf(val)}`;
    }
  };

  // wraps a function to check its arguments types and result type
  fn = function(argTypes, resType, f) {
    if (!Array.isArray(argTypes)) {
      error("@Array of arguments types is missing.");
    }
    if (resType instanceof Function && !resType.name) {
      error("@Result type is missing.");
    }
    if (!(f instanceof Function && !f.name)) {
      error("@Function to wrap is missing.");
    }
    if (arguments.length > 3) {
      error("@Too many arguments.");
    }
    return function(...args) { // returns an unfortunately anonymous function
      var arg, i, j, l, len, len1, m, ref, rest, result, t, type;
      rest = false;
      for (i = l = 0, len = argTypes.length; l < len; i = ++l) {
        type = argTypes[i];
        if (type === EtcHelper || type instanceof Etc$1) { // rest type
          if (i + 1 < argTypes.length) {
            error("@Rest type must be the last of the arguments types.");
          }
          rest = true;
          t = (type === EtcHelper ? type() : type).type; // using default helper parameters
          if (!isAnyType(t)) {
            ref = args.slice(i);
            for (j = m = 0, len1 = ref.length; m < len1; j = ++m) {
              arg = ref[j];
              if (!isType(arg, t)) {
                error(`Argument number ${i + j + 1} ${shouldBe(arg, t)}.`);
              }
            }
          }
        } else {
          if (!isAnyType(type)) {
            if (args[i] === void 0) {
              if (!isType(void 0, type)) {
                error(`Missing required argument number ${i + 1}.`);
              }
            } else {
              if (!isType(args[i], type)) {
                error(`Argument number ${i + 1} ${shouldBe(args[i], type)}.`);
              }
            }
          }
        }
      }
      if (args.length > argTypes.length && !rest) {
        error("Too many arguments provided.");
      }
      if (resType instanceof Promise) {
        // NB: not using `await` because CS would transpile the returned function as an async one
        return resType.then(function(promiseType) {
          var promise;
          promise = f(...args);
          if (!(promise instanceof Promise)) {
            error(`Result ${shouldBe(promise, promiseType, true)}.`);
          }
          return promise.then(function(result) {
            if (!isType(result, promiseType)) {
              error(`Promise result ${shouldBe(result, promiseType)}.`);
            }
            return result;
          });
        });
      } else {
        result = f(...args);
        if (!isType(result, resType)) {
          error(`Result ${shouldBe(result, resType)}.`);
        }
        return result;
      }
    };
  };

  var dist = {fn, typeOf, isType, isAnyType, getTypeName};

  const TIMES = 100 * 1000;
  const SIZE = 100;
  const { fn: fn$1 } = dist;
  let title = "";

  console.log("\n*** Floweret ***");

  // example from https://codemix.github.io/flow-runtime/#/
  const Person = {name: String};
  const greet = fn$1(
  	[Person], String,
  	function (person) {
  		return 'Hello ' + person.name
  	}
  );

  title = `${TIMES} times greet`;
  console.time(title);
  for (let i = 0; i < TIMES; i++) {
  	greet({ name: 'Alice' });
  }
  console.timeEnd(title);


  const f = fn$1(
  	[Array(Number)], Number,
  	function (a) {
  		return a.length
  	}
  );
  const a = [...Array(SIZE).keys()];

  title = `${TIMES} times ${SIZE} elements`;
  console.time(title);
  for (let i = 0; i < TIMES; i++) {
  	f(a);
  }
  console.timeEnd(title);

  var floweret = {

  };

  return floweret;

})));
