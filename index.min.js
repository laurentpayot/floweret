/** @license MIT (c) 2018 Laurent Payot  */
var Etc,TypedMap,TypedObject,TypedSet,anyType,error,etc,isAnyType,isType,maybe,promised,sig,typeName,typeOf,typedMap,typedObject,typedSet;error=function(e){throw new Error(function(){switch(e[0]){case"!":return`Invalid type syntax: ${e.slice(1)}`;case"@":return`Invalid signature: ${e.slice(1)}`;default:return`Type error: ${e}`}}())};TypedObject=class TypedObject{constructor(e){this.type=e;if(arguments.length!==1){error("!typedObject must have exactly one type argument.")}if(isAnyType(this.type)){return Object}}};TypedSet=class TypedSet{constructor(e){this.type=e;if(arguments.length!==1){error("!typedSet must have exactly one type argument.")}if(isAnyType(this.type)){return Set}}};TypedMap=function(){class TypedMap{constructor(e,t){switch(arguments.length){case 0:error("!typedMap must have at least one type argument.");break;case 1:if(isAnyType(e)){return Map}else{this.valuesType=e}break;case 2:if(isAnyType(e)&&isAnyType(t)){return Map}else{[this.keysType,this.valuesType]=[e,t]}break;default:error("!typedMap can not have more than two type arguments.")}}}TypedMap.prototype.keysType=[];TypedMap.prototype.valuesType=[];return TypedMap}.call(this);Etc=class Etc{constructor(e=[]){this.type=e;if(arguments.length>1){error("!'etc' can not have more than one type argument.")}}};isAnyType=function(e){return e===anyType||Array.isArray(e)&&e.length===0};anyType=function(){if(arguments.length){return error("!'anyType' can not have a type argument.")}else{return[]}};maybe=function(...e){if(!arguments.length){error("!'maybe' must have at least one type argument.")}if(e.some(function(e){return isAnyType(e)})){return[]}else{return[void 0,null].concat(e)}};promised=function(e){if(arguments.length!==1){error("!'promised' must have exactly one type argument.")}if(isAnyType(e)){return Promise}else{return Promise.resolve(e)}};typedObject=function(...e){return new TypedObject(...e)};typedSet=function(...e){return new TypedSet(...e)};typedMap=function(...e){return new TypedMap(...e)};etc=function(...e){return new Etc(...e)};typeOf=function(e){if(e===void 0||e===null){return""+e}else{return e.constructor.name}};isType=function(e,t){var r,n,s,y,u,i,a,o,p,c;switch(typeOf(t)){case"undefined":case"null":case"String":case"Number":case"Boolean":return e===t;case"Function":switch(t){case anyType:return true;case promised:case maybe:case typedObject:case typedSet:case typedMap:return error(`!'${t.name}' can not be used directly as a function.`);case etc:return error("!'etc' can not be used in types.!!!");default:return(e!=null?e.constructor:void 0)===t}break;case"Array":switch(t.length){case 0:return true;case 1:if(!Array.isArray(e)){return false}if(isAnyType(t[0])){return true}return e.every(function(e){return isType(e,t[0])});default:return t.some(function(t){return isType(e,t)})}break;case"Object":if((e!=null?e.constructor:void 0)!==Object){return false}if(!Object.keys(t).length){return!Object.keys(e).length}for(r in t){o=t[r];if(!isType(e[r],o)){return false}}return true;case"TypedObject":if((e!=null?e.constructor:void 0)!==Object){return false}a=t.type;if(isAnyType(a)){return true}return Object.values(e).every(function(e){return isType(e,a)});case"TypedSet":if((e!=null?e.constructor:void 0)!==Set){return false}a=t.type;if(isAnyType(a)){return true}if((u=typeOf(a))==="undefined"||u==="null"||u==="String"||u==="Number"||u==="Boolean"){error(`!Typed Set type can not be a literal of type '${a}'.`)}return[...e].every(function(e){return isType(e,a)});case"TypedMap":if((e!=null?e.constructor:void 0)!==Map){return false}({keysType:s,valuesType:c}=t);switch(false){case!(isAnyType(s)&&isAnyType(c)):return true;case!isAnyType(s):return Array.from(e.values()).every(function(e){return isType(e,c)});case!isAnyType(c):return Array.from(e.keys()).every(function(e){return isType(e,s)});default:n=Array.from(e.keys());p=Array.from(e.values());return n.every(function(e){return isType(e,s)})&&p.every(function(e){return isType(e,c)})}break;case"Etc":return error("!'etc' can not be used in types.");default:y=(i=typeOf(t))==="Set"||i==="Map"?"the provided Typed":"";return error(`!Type can not be an instance of ${typeOf(t)}. Use ${y}${typeOf(t)} as type instead.`)}};typeName=function(e){var t;switch(typeOf(e)){case"Array":if(e.length===1){return`array of ${typeName(e[0])}`}else{return function(){var r,n,s;s=[];for(r=0,n=e.length;r<n;r++){t=e[r];s.push(typeName(t))}return s}().join(" or ")}break;case"Function":return e.name;case"Object":return"custom type";default:return typeOf(e)}};sig=function(e,t,r){if(!Array.isArray(e)){error("@Array of arguments types is missing.")}if((t!=null?t.constructor:void 0)===Function&&!t.name){error("@Result type is missing.")}if((r!=null?r.constructor:void 0)!==Function){error("@Function to wrap is missing.")}return function(...n){var s,y,u,i,a,o,p,c,f,l,d,T;f=false;for(y=i=0,a=e.length;i<a;y=++i){T=e[y];if(T===etc||(T!=null?T.constructor:void 0)===Etc){if(y+1<e.length){error("@Rest type must be the last of the arguments types.")}f=true;d=T===etc?[]:T.type;if(!isAnyType(d)){c=n.slice(y);for(u=p=0,o=c.length;p<o;u=++p){s=c[u];if(!isType(s,d)){error(`Argument number ${y+u+1} (${s}) should be of type ${typeName(d)} instead of ${typeOf(s)}.`)}}}}else{if(!isAnyType(T)){if(n[y]===void 0){if(!isType(void 0,T)){error(`Missing required argument number ${y+1}.`)}}else{if(!isType(n[y],T)){error(`Argument number ${y+1} (${n[y]}) should be of type ${typeName(T)} instead of ${typeOf(n[y])}.`)}}}}}if(n.length>e.length&&!f){error("Too many arguments provided.")}if((t!=null?t.constructor:void 0)===Promise){return t.then(function(e){var t;t=r(...n);if((t!=null?t.constructor:void 0)!==Promise){error("Function should return a promise.")}return t.then(function(t){if(!isType(t,e)){error(`Promise result (${t}) should be of type ${typeName(e)} instead of ${typeOf(t)}.`)}return t})})}else{l=r(...n);if(!isType(l,t)){error(`Result (${l}) should be of type ${typeName(t)} instead of ${typeOf(l)}.`)}return l}}};module.exports={typeOf:typeOf,isType:isType,sig:sig,maybe:maybe,anyType:anyType,promised:promised,etc:etc,typedObject:typedObject,typedSet:typedSet,typedMap:typedMap};