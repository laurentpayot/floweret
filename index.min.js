/** @license MIT (c) 2018 Laurent Payot  */
var Etc,TypedMap,TypedObject,TypedSet,anyType,error,etc,isAnyType,isType,maybe,promised,sig,typeName,typeOf,typedMap,typedObject,typedSet;error=function(e){throw new Error(function(){switch(e[0]){case"!":return`Invalid type syntax: ${e.slice(1)}`;case"@":return`Invalid signature: ${e.slice(1)}`;default:return`Type error: ${e}`}}())};TypedObject=class e{constructor(e){this.type=e;if(arguments.length!==1){error("!typedObject must have exactly one type argument.")}if(isAnyType(this.type)){return Object}}};TypedSet=class e{constructor(e){this.type=e;if(arguments.length!==1){error("!typedSet must have exactly one type argument.")}if(isAnyType(this.type)){return Set}}};TypedMap=function(){class e{constructor(e,t){switch(arguments.length){case 0:error("!typedMap must have at least one type argument.");break;case 1:if(isAnyType(e)){return Map}else{this.valuesType=e}break;case 2:if(isAnyType(e)&&isAnyType(t)){return Map}else{[this.keysType,this.valuesType]=[e,t]}break;default:error("!typedMap can not have more than two type arguments.")}}}e.prototype.keysType=[];e.prototype.valuesType=[];return e}.call(this);Etc=class e{constructor(e=[]){this.type=e;if(arguments.length>1){error("!'etc' can not have more than one type argument.")}}};isAnyType=function(e){return e===anyType||Array.isArray(e)&&e.length===0};anyType=function(){if(arguments.length){return error("!'anyType' can not have a type argument.")}else{return[]}};maybe=function(...e){if(!arguments.length){error("!'maybe' must have at least one type argument.")}if(e.some(function(e){return isAnyType(e)})){return[]}else{return[void 0,null].concat(e)}};promised=function(e){if(arguments.length!==1){error("!'promised' must have exactly one type argument.")}if(isAnyType(e)){return Promise}else{return Promise.resolve(e)}};typedObject=function(...e){return new TypedObject(...e)};typedSet=function(...e){return new TypedSet(...e)};typedMap=function(...e){return new TypedMap(...e)};etc=function(...e){return new Etc(...e)};typeOf=function(e){if(e===void 0||e===null){return""+e}else{return e.constructor.name}};isType=function(e,t){var r,n,s,y,i,u,o,a,p,c;if(Array.isArray(t)){switch(t.length){case 0:return true;case 1:if(!Array.isArray(e)){return false}if(isAnyType(t[0])){return true}return e.every(function(e){return isType(e,t[0])});default:return t.some(function(t){return isType(e,t)})}}else{switch(t!=null?t.constructor:void 0){case void 0:case String:case Number:case Boolean:return e===t;case Function:switch(t){case anyType:return true;case promised:case maybe:case typedObject:case typedSet:case typedMap:return error(`!'${t.name}' can not be used directly as a function.`);case etc:return error("!'etc' can not be used in types.!!!");default:return(e!=null?e.constructor:void 0)===t}break;case Object:if((e!=null?e.constructor:void 0)!==Object){return false}if(!Object.keys(t).length){return!Object.keys(e).length}for(r in t){a=t[r];if(!isType(e[r],a)){return false}}return true;case TypedObject:if((e!=null?e.constructor:void 0)!==Object){return false}o=t.type;if(isAnyType(o)){return true}return Object.values(e).every(function(e){return isType(e,o)});case TypedSet:if((e!=null?e.constructor:void 0)!==Set){return false}o=t.type;if(isAnyType(o)){return true}if((i=typeOf(o))==="undefined"||i==="null"||i==="String"||i==="Number"||i==="Boolean"){error(`!Typed Set type can not be a literal of type '${o}'.`)}return[...e].every(function(e){return isType(e,o)});case TypedMap:if((e!=null?e.constructor:void 0)!==Map){return false}({keysType:s,valuesType:c}=t);switch(false){case!(isAnyType(s)&&isAnyType(c)):return true;case!isAnyType(s):return Array.from(e.values()).every(function(e){return isType(e,c)});case!isAnyType(c):return Array.from(e.keys()).every(function(e){return isType(e,s)});default:n=Array.from(e.keys());p=Array.from(e.values());return n.every(function(e){return isType(e,s)})&&p.every(function(e){return isType(e,c)})}break;case Etc:return error("!'etc' can not be used in types.");default:y=(u=t.constructor)===Set||u===Map?"the provided Typed":"";return error(`!Type can not be an instance of ${typeOf(t)}. Use ${y}${typeOf(t)} as type instead.`)}}};typeName=function(e){var t;switch(typeOf(e)){case"Array":if(e.length===1){return`array of ${typeName(e[0])}`}else{return function(){var r,n,s;s=[];for(r=0,n=e.length;r<n;r++){t=e[r];s.push(typeName(t))}return s}().join(" or ")}break;case"Function":return e.name;case"Object":return"custom type";default:return typeOf(e)}};sig=function(e,t,r){if(!Array.isArray(e)){error("@Array of arguments types is missing.")}if((t!=null?t.constructor:void 0)===Function&&!t.name){error("@Result type is missing.")}if((r!=null?r.constructor:void 0)!==Function){error("@Function to wrap is missing.")}return function(...n){var s,y,i,u,o,a,p,c,f,l,d,m;f=false;for(y=u=0,o=e.length;u<o;y=++u){m=e[y];if(m===etc||(m!=null?m.constructor:void 0)===Etc){if(y+1<e.length){error("@Rest type must be the last of the arguments types.")}f=true;d=m===etc?[]:m.type;if(!isAnyType(d)){c=n.slice(y);for(i=p=0,a=c.length;p<a;i=++p){s=c[i];if(!isType(s,d)){error(`Argument number ${y+i+1} (${s}) should be of type ${typeName(d)} instead of ${typeOf(s)}.`)}}}}else{if(!isAnyType(m)){if(n[y]===void 0){if(!isType(void 0,m)){error(`Missing required argument number ${y+1}.`)}}else{if(!isType(n[y],m)){error(`Argument number ${y+1} (${n[y]}) should be of type ${typeName(m)} instead of ${typeOf(n[y])}.`)}}}}}if(n.length>e.length&&!f){error("Too many arguments provided.")}if((t!=null?t.constructor:void 0)===Promise){return t.then(function(e){var t;t=r(...n);if((t!=null?t.constructor:void 0)!==Promise){error("Function should return a promise.")}return t.then(function(t){if(!isType(t,e)){error(`Promise result (${t}) should be of type ${typeName(e)} instead of ${typeOf(t)}.`)}return t})})}else{l=r(...n);if(!isType(l,t)){error(`Result (${l}) should be of type ${typeName(t)} instead of ${typeOf(l)}.`)}return l}}};module.exports={typeOf:typeOf,isType:isType,sig:sig,maybe:maybe,anyType:anyType,promised:promised,etc:etc,typedObject:typedObject,typedSet:typedSet,typedMap:typedMap};