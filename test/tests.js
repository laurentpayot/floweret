// Generated by CoffeeScript 2.3.1
(function() {
  var NATIVE_TYPES, VALUES, chai, chaiAsPromised, expect, isType, maybe, promised, sig, testTypes, typeOf;

  ({typeOf, isType, sig, maybe, promised} = require('../index.js')); // testing the build, not the source

  chai = require('chai');

  chaiAsPromised = require('chai-as-promised');

  chai.use(chaiAsPromised);

  expect = chai.expect;

  NATIVE_TYPES = [void 0, null, Boolean, Number, String, Array, Date, Object, Function, Promise, Int8Array, Set, Map, Symbol];

  VALUES = [
    void 0,
    null,
    1.1, // number
    0, // number
    true, // boolean
    false, // boolean
    "", // string
    "a", // string
    " ", // string
    "Énorme !", // string
    //array
    [],
    [
      1,
      'a',
      null,
      void 0 //array
    ],
    new Int8Array([
      1,
      2 // typed array
    // object
    ]),
    {},
    {
      foo: 'bar' // object
    },
    {
      name: 'Number' // tricky object
    },
    {
      a: 1,
      b: {
        a: 2,
        b: null,
        c: '3' // object
      }
    },
    new Date(),
    (function() {}), // function
    new Promise(function() {}), // promise
    new Set([]), // set
    new Set([1,
    2]),
    new Map([]), // map
    new Map([[1,
    'one'],
    [2,
    'two']]),
    Symbol('foo') // symbol
  ];

  testTypes = function(val, type) {
    var i, len, results, t;
    expect(isType(val, type)).to.be.true;
    results = [];
    for (i = 0, len = NATIVE_TYPES.length; i < len; i++) {
      t = NATIVE_TYPES[i];
      if (t !== type) {
        results.push(expect(isType(val, t)).to.be.false);
      }
    }
    return results;
  };

  /*
  	████████╗██╗   ██╗██████╗ ███████╗ ██████╗ ███████╗
  	╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝██╔═══██╗██╔════╝
  		██║    ╚████╔╝ ██████╔╝█████╗  ██║   ██║█████╗
  		██║     ╚██╔╝  ██╔═══╝ ██╔══╝  ██║   ██║██╔══╝
  		██║      ██║   ██║     ███████╗╚██████╔╝██║
  		╚═╝      ╚═╝   ╚═╝     ╚══════╝ ╚═════╝ ╚═╝
  */
  describe("typeOf", function() {
    return it("TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", function() {});
  });

  /*
  	██╗███████╗████████╗██╗   ██╗██████╗ ███████╗
  	██║██╔════╝╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝
  	██║███████╗   ██║    ╚████╔╝ ██████╔╝█████╗
  	██║╚════██║   ██║     ╚██╔╝  ██╔═══╝ ██╔══╝
  	██║███████║   ██║      ██║   ██║     ███████╗
  	╚═╝╚══════╝   ╚═╝      ╚═╝   ╚═╝     ╚══════╝
  */
  describe("isType", function() {
    context("Special Types", function() {
      context("Maybe type", function() {
        it("should return true when value is undefined or null.", function() {
          var i, len, results, t;
          results = [];
          for (i = 0, len = NATIVE_TYPES.length; i < len; i++) {
            t = NATIVE_TYPES[i];
            expect(isType(void 0, maybe(t))).to.be.true;
            results.push(expect(isType(null, maybe(t))).to.be.true);
          }
          return results;
        });
        it("should return true for a number type, false for other types.", function() {
          var i, len, results, t;
          expect(isType(1.1, maybe(Number))).to.be.true;
          results = [];
          for (i = 0, len = NATIVE_TYPES.length; i < len; i++) {
            t = NATIVE_TYPES[i];
            if (t && t !== Number) {
              results.push(expect(isType(1.1, maybe(t))).to.be.false);
            }
          }
          return results;
        });
        return it("should return true for a string type, false for other types.", function() {
          var i, len, results, t;
          expect(isType("Énorme !", maybe(String))).to.be.true;
          results = [];
          for (i = 0, len = NATIVE_TYPES.length; i < len; i++) {
            t = NATIVE_TYPES[i];
            if (t && t !== String) {
              results.push(expect(isType("Énorme !", maybe(t))).to.be.false);
            }
          }
          return results;
        });
      });
      return context("Any type ([])", function() {
        return it("should return true for all values", function() {
          var i, len, results, val;
          results = [];
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            results.push(expect(isType(val, [])).to.be.true);
          }
          return results;
        });
      });
    });
    context("Invalid Types", function() {
      it("should throw an error when type is not a native type nor an object nor an array of types", function() {
        var i, j, len, len1, results, val;
        for (i = 0, len = VALUES.length; i < len; i++) {
          val = VALUES[i];
          expect(function() {
            return isType(val, 'Number');
          }).to.throw("Type can not be 'Number'. Use String class instead.");
        }
        results = [];
        for (j = 0, len1 = VALUES.length; j < len1; j++) {
          val = VALUES[j];
          results.push(expect(function() {
            return isType(val, 1);
          }).to.throw("Type can not be '1'. Use Number class instead."));
        }
        return results;
      });
      return it("should throw an error when type is an empty object", function() {
        var i, len, results, val;
        results = [];
        for (i = 0, len = VALUES.length; i < len; i++) {
          val = VALUES[i];
          results.push(expect(function() {
            return isType(val, {});
          }).to.throw("Type can not be an empty object."));
        }
        return results;
      });
    });
    context("Native Types", function() {
      it("should return true for an undefined type, false for other types", function() {
        return testTypes(void 0, void 0);
      });
      it("should return true for a null type, false for other types", function() {
        return testTypes(null, null);
      });
      it("should return true for a number type, false for other types", function() {
        testTypes(1.1, Number);
        return testTypes(0, Number);
      });
      it("should return true for a boolean type, false for other types", function() {
        testTypes(true, Boolean);
        return testTypes(false, Boolean);
      });
      it("should return true for a string type, false for other types", function() {
        testTypes('', String);
        return testTypes("Énorme !", String);
      });
      it("should return true for an array type, false for other types", function() {
        return testTypes([1, 'a'], Array);
      });
      it("should return true for a date type, false for other types", function() {
        return testTypes(new Date(), Date);
      });
      it("should return true for an object type, false for other types", function() {
        testTypes({}, Object);
        return testTypes({
          foo: 'bar'
        }, Object);
      });
      it("should return true for a set type, false for other types", function() {
        testTypes(new Set([]), Set);
        return testTypes(new Set([1, 2]), Set);
      });
      it("should return true for a promise type, false for other types", function() {
        testTypes(new Promise(function() {}), Promise);
        return testTypes(new Promise(function(resolve, reject) {
          return resolve();
        }), Promise);
      });
      it("should return true for a function type, false for other types", function() {
        testTypes((function() {}), Function);
        return testTypes((function(a) {
          return a + 1;
        }), Function);
      });
      return it("should return true for a factory function value and function type, false for other types", function() {
        testTypes((function(foo) {
          return function(bar) {
            return foo + bar;
          };
        }), Function);
        return testTypes((function(foo) {
          return function(bar) {
            return new Promise(function(resolve, reject) {
              return resolve(foo + bar);
            });
          };
        }), Function);
      });
    });
    context("Custom Types", function() {
      it("should return false for a custom type and non object values", function() {
        var UserType, i, len, results, val;
        UserType = {
          id: Number,
          name: String
        };
        expect(isType(void 0, UserType)).to.be.false;
        expect(isType(null, UserType)).to.be.false;
        results = [];
        for (i = 0, len = VALUES.length; i < len; i++) {
          val = VALUES[i];
          if (val !== void 0 && val !== null && val.constructor !== Object) {
            results.push(expect(isType(val, UserType)).to.be.false);
          }
        }
        return results;
      });
      it("should return true for a shallow custom type, false otherwise", function() {
        var UserType;
        UserType = {
          id: Number,
          name: String
        };
        expect(isType({
          id: 1234,
          name: "Smith"
        }, UserType)).to.be.true;
        expect(isType({
          foo: 1234,
          name: "Smith"
        }, UserType)).to.be.false;
        expect(isType({
          id: '1234',
          name: "Smith"
        }, UserType)).to.be.false;
        expect(isType({
          id: 1234,
          name: ["Smith"]
        }, UserType)).to.be.false;
        expect(isType({
          name: "Smith"
        }, UserType)).to.be.false;
        expect(isType({
          id: 1234
        }, UserType)).to.be.false;
        return expect(isType({}, UserType)).to.be.false;
      });
      it("should return true for a deep custom type, false otherwise", function() {
        var UserType;
        UserType = {
          id: Number,
          name: {
            firstName: String,
            lastName: String,
            middleName: [String, void 0]
          }
        };
        expect(isType({
          id: 1234,
          name: {
            firstName: "John",
            lastName: "Smith",
            middleName: "Jack"
          }
        }, UserType)).to.be.true;
        expect(isType({
          id: 1234,
          name: {
            firstName: "John",
            lastName: "Smith",
            middleName: 1
          }
        }, UserType)).to.be.false;
        expect(isType({
          id: 1234,
          name: {
            firstName: "John",
            lastName: "Smith"
          }
        }, UserType)).to.be.true;
        expect(isType({
          id: 1234
        }, UserType)).to.be.false;
        expect(isType({
          name: {
            firstName: "John",
            lastName: "Smith"
          }
        }, UserType)).to.be.false;
        expect(isType({
          id: 1234,
          name: {
            firstName: "John"
          }
        }, UserType)).to.be.false;
        expect(isType({
          id: 1234,
          name: {
            firstName: "John",
            lostName: "Smith"
          }
        }, UserType)).to.be.false;
        expect(isType({
          id: 1234,
          name: {
            firstName: "John",
            lastName: [1]
          }
        }, UserType)).to.be.false;
        expect(isType({
          id: '1234',
          name: "Smith"
        }, UserType)).to.be.false;
        return expect(isType({
          id: 1234,
          name: ["Smith"]
        }, UserType)).to.be.false;
      });
      return it("should return false for custom type {name: 'Number'} and a number value", function() {
        return expect(isType(1, {
          name: 'Number'
        })).to.be.false;
      });
    });
    context("Several Types", function() {
      it("should return true for a string or a number value, false otherwise", function() {
        expect(isType("foo", [String, Number])).to.be.true;
        expect(isType(1234, [String, Number])).to.be.true;
        expect(isType(null, [String, Number])).to.be.false;
        expect(isType({}, [String, Number])).to.be.false;
        return expect(isType(new Date(), [Object, Number])).to.be.false;
      });
      it("should return true for a string or null value, false otherwise", function() {
        expect(isType("foo", [String, null])).to.be.true;
        expect(isType(null, [String, null])).to.be.true;
        return expect(isType(1234, [String, null])).to.be.false;
      });
      it("should return true for an object or null value, false otherwise", function() {
        expect(isType({
          id: 1234,
          name: "Smith"
        }, [Object, null])).to.be.true;
        expect(isType(null, [Object, null])).to.be.true;
        return expect(isType("foo", [Object, null])).to.be.false;
      });
      return it("should return true for a custom type or null value, false otherwise", function() {
        var UserType;
        UserType = {
          id: Number,
          name: String
        };
        expect(isType({
          id: 1234,
          name: "Smith"
        }, [UserType, null])).to.be.true;
        expect(isType(null, [UserType, null])).to.be.true;
        return expect(isType("foo", [UserType, null])).to.be.false;
      });
    });
    return context("Typed array", function() {
      context("Native Types", function() {
        it("should return false when value is not an array", function() {
          var i, j, len, len1, results, val;
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            if (!Array.isArray(val)) {
              expect(isType(val, Array(Number))).to.be.false;
            }
          }
          results = [];
          for (j = 0, len1 = VALUES.length; j < len1; j++) {
            val = VALUES[j];
            if (!Array.isArray(val)) {
              results.push(expect(isType(val, Array(String))).to.be.false);
            }
          }
          return results;
        });
        it("should return true for an array of numbers", function() {
          expect(isType([1, 2, 3], Array(Number))).to.be.true;
          expect(isType([1], Array(Number))).to.be.true;
          return expect(isType([], Array(Number))).to.be.true;
        });
        it("should return true for an array of strings", function() {
          expect(isType(["foo", "bar", "baz"], Array(String))).to.be.true;
          expect(isType(["foo"], Array(String))).to.be.true;
          return expect(isType([], Array(String))).to.be.true;
        });
        it("should return false when an element of the array is not a number", function() {
          var i, j, len, len1, results, val;
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            if (typeof val !== 'number') {
              expect(isType([1, val, 3], Array(Number))).to.be.false;
            }
          }
          results = [];
          for (j = 0, len1 = VALUES.length; j < len1; j++) {
            val = VALUES[j];
            if (typeof val !== 'number') {
              results.push(expect(isType([val], Array(Number))).to.be.false);
            }
          }
          return results;
        });
        return it("should return false when an element of the array is not a string", function() {
          var i, j, len, len1, results, val;
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            if (typeof val !== 'string') {
              expect(isType(["foo", val, "bar"], Array(String))).to.be.false;
            }
          }
          results = [];
          for (j = 0, len1 = VALUES.length; j < len1; j++) {
            val = VALUES[j];
            if (typeof val !== 'string') {
              results.push(expect(isType([val], Array(String))).to.be.false);
            }
          }
          return results;
        });
      });
      context("Custom Types", function() {
        it("should return false when value is not an array", function() {
          var i, len, nsType, results, val;
          nsType = {
            n: Number,
            s: String
          };
          results = [];
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            if (!Array.isArray(val)) {
              results.push(expect(isType(val, Array(nsType))).to.be.false);
            }
          }
          return results;
        });
        it("should return true when all elements of the array are of a given custom type", function() {
          var nsType;
          nsType = {
            n: Number,
            s: String
          };
          expect(isType([
            {
              n: 1,
              s: "a"
            },
            {
              n: 2,
              s: "b"
            },
            {
              n: 3,
              s: "c"
            }
          ], Array(nsType))).to.be.true;
          expect(isType([
            {
              n: 1,
              s: "a"
            }
          ], Array(nsType))).to.be.true;
          return expect(isType([], Array(nsType))).to.be.true;
        });
        return it("should return false when some elements of the array are not of a given custom type", function() {
          var i, j, len, len1, nsType, val;
          nsType = {
            n: Number,
            s: String
          };
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            expect(isType([
              {
                n: 1,
                s: "a"
              },
              val,
              {
                n: 3,
                s: "c"
              }
            ], Array(nsType))).to.be.false;
          }
          for (j = 0, len1 = VALUES.length; j < len1; j++) {
            val = VALUES[j];
            expect(isType([val], Array(nsType))).to.be.false;
          }
          return expect(isType([
            {
              n: 1,
              s: "a"
            },
            {
              foo: 2,
              s: "b"
            },
            {
              n: 3,
              s: "c"
            }
          ], Array(nsType))).to.be.false;
        });
      });
      return context("Several Types", function() {
        it("should return false when value is not an array", function() {
          var i, len, results, val;
          results = [];
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            if (!Array.isArray(val)) {
              results.push(expect(isType(val, Array([Number, String]))).to.be.false);
            }
          }
          return results;
        });
        it("should return true for an array whom values are strings or numbers", function() {
          expect(isType([], Array([String, Number]))).to.be.true;
          expect(isType(["foo", "bar", "baz"], Array([String, Number]))).to.be.true;
          expect(isType(["foo"], Array([String, Number]))).to.be.true;
          expect(isType([1, 2, 3], Array([String, Number]))).to.be.true;
          expect(isType([1], Array([String, Number]))).to.be.true;
          expect(isType(["foo", 1, "bar"], Array([String, Number]))).to.be.true;
          return expect(isType([1, "foo", 2], Array([String, Number]))).to.be.true;
        });
        return it("should return false when an element of the array is not a string nor a number", function() {
          var i, j, len, len1, results, val;
          for (i = 0, len = VALUES.length; i < len; i++) {
            val = VALUES[i];
            if (typeof val !== 'string' && typeof val !== 'number') {
              expect(isType(["foo", val, 1], Array([String, Number]))).to.be.false;
            }
          }
          results = [];
          for (j = 0, len1 = VALUES.length; j < len1; j++) {
            val = VALUES[j];
            if (typeof val !== 'string' && typeof val !== 'number') {
              results.push(expect(isType([val], Array([String, Number]))).to.be.false);
            }
          }
          return results;
        });
      });
    });
  });

  /*
  	███████╗██╗ ██████╗
  	██╔════╝██║██╔════╝
  	███████╗██║██║  ███╗
  	╚════██║██║██║   ██║
  	███████║██║╚██████╔╝
  	╚══════╝╚═╝ ╚═════╝
  */
  describe("sig", function() {
    context("Synchronous functions", function() {
      it("should do nothing if function returns a string", function() {
        var f;
        f = sig([], String, function() {
          return "foo";
        });
        return expect(f()).to.equal("foo");
      });
      return it("should throw an error if function returns a number", function() {
        var f;
        f = sig([], String, function() {
          return 1;
        });
        return expect(function() {
          return f();
        }).to.throw("Result (1) should be of type String instead of Number.");
      });
    });
    context("Asynchronous functions", function() {
      it("should return a promise if function returns promise", function() {
        var f;
        f = sig([], promised(Number), function() {
          return Promise.resolve(1);
        });
        return expect(typeOf(f())).to.equal('Promise');
      });
      it("should do nothing if function returns a string promise", function() {
        var f;
        f = sig([], promised(String), function() {
          return Promise.resolve("foo");
        });
        return expect(f()).to.eventually.equal("foo");
      });
      return it("should throw an error if function returns a number promise", function() {
        var f;
        f = sig([], promised(String), function() {
          return Promise.resolve(1);
        });
        return expect(f()).to.be.rejectedWith("Promise result (1) should be of type String instead of Number.");
      });
    });
    return context("Arguments number", function() {
      it("should do nothing if function has the right number of arguments", function() {
        var f;
        f = sig([Number, [Number, String]], [], function(n1, n2 = 0) {
          return n1 + n2;
        });
        return expect(f(1, 2)).to.equal(3);
      });
      it("should raise an error if function has too many arguments", function() {
        var f;
        f = sig([Number, [Number, String]], [], function(n1, n2 = 0) {
          return n1 + n2;
        });
        return expect(function() {
          return f(1, 2, 3);
        }).to.throw("Too many arguments provided.");
      });
      it("should raise an error if function has too few arguments", function() {
        var f;
        f = sig([Number, [Number, String]], [], function(n1, n2 = 0) {
          return n1 + n2;
        });
        return expect(function() {
          return f(1);
        }).to.throw("Missing required argument number 2.");
      });
      it("should do nothing if all unfilled arguments are optional", function() {
        var f;
        f = sig([Number, [Number, String, void 0]], [], function(n1, n2 = 0) {
          return n1 + n2;
        });
        expect(f(1)).to.equal(1);
        expect(f(1, void 0)).to.equal(1);
        f = sig([Number, [Number, String, void 0], Number], [], function(n1, n2 = 0, n3) {
          return n1 + n2 + n3;
        });
        return expect(f(1, void 0, 3)).to.equal(4);
      });
      it("should do nothing if all unfilled arguments type is any type", function() {
        var f;
        f = sig([Number, []], [], function(n1, n2 = 0) {
          return n1 + n2;
        });
        expect(f(1)).to.equal(1);
        expect(f(1, void 0)).to.equal(1);
        f = sig([Number, [], Number], [], function(n1, n2 = 0, n3) {
          return n1 + n2 + n3;
        });
        return expect(f(1, void 0, 3)).to.equal(4);
      });
      it("should raise an error if some unfilled arguments are not optional", function() {
        var f;
        f = sig([Number, [Number, String, void 0], Number], [], function(n1, n2 = 0, n3) {
          return n1 + n2 + n3;
        });
        expect(function() {
          return f(1);
        }).to.throw("Missing required argument number 3.");
        return expect(function() {
          return f(1, 2);
        }).to.throw("Missing required argument number 3.");
      });
      it("should raise an error when an optional argument is filled with null", function() {
        var f;
        f = sig([Number, [Number, void 0]], [], function(n1, n2 = 0) {
          return n1 + n2;
        });
        return expect(function() {
          return f(1, null);
        }).to.throw("Argument number 2 (null) should be of type Number or Undefined instead of Null");
      });
      it("should raise an error when only an optional argument and value is null", function() {
        var f;
        f = sig([void 0], [], function(n1 = 0) {
          return n1;
        });
        return expect(function() {
          return f(null);
        }).to.throw("Argument number 1 (null) should be of type Undefined instead of Null.");
      });
      it("should raise an error when only an optional argument and value isnt undefined", function() {
        var f;
        f = sig([void 0], [], function(n1 = 0) {
          return n1;
        });
        return expect(function() {
          return f(1);
        }).to.throw("Argument number 1 (1) should be of type Undefined instead of Number.");
      });
      it("should do nothing if only an optional argument and value is undefined", function() {
        var f;
        f = sig([void 0], [], function(n1 = 0) {
          return n1;
        });
        return expect(f(void 0)).to.equal(0);
      });
      return it("should do nothing if only an optional argument and value is not filled", function() {
        var f;
        f = sig([void 0], [], function(n1 = 0) {
          return n1;
        });
        return expect(f()).to.equal(0);
      });
    });
  });

}).call(this);
