import {NATIVE_TYPES, VALUES} from './fixtures'
import {isValid, Any} from '../src'
import {
	Type, promised, constraint, foreign,
	Integer, Natural, SizedString, Tuple, TypedObject, TypedSet, TypedMap,
	and as And, or as Or, not as Not
} from '../src/types/_index'


testTypes = (val, type) ->
	expect(isValid(val, type)).toBe(true)
	expect(isValid(val, t)).toBe(false) \
		for t in NATIVE_TYPES when not(t is type or Number.isNaN val and Number.isNaN type)
	return # Jest: `it` and `test` must return either a Promise or undefined.


describe "Special Types", ->

	describe "Empty array", ->

		test.only "return true for empty array only", ->
			expect(isValid([], [])).toBe(true)
			# expect(isValid(v, [])).toBe(false) for v in VALUES when not (Array.isArray(v) and not v.length)
			return

	describe "Empty object", ->

		test "return true for empty object only", ->
			expect(isValid({}, {})).toBe(true)
			expect(isValid(v, {})).toBe(false) for v in VALUES \
				when not (v?.constructor is Object and isEmptyObject(v))

	describe "Any type", ->

		test "Any type should return true for all values", ->
			expect(isValid(val, Any)).toBe(true) for val in VALUES

		test "Any() type should return true for all values", ->
			expect(isValid(val, Any())).toBe(true) for val in VALUES

		test "Any(Number) type should throw an error", ->
			expect(-> isValid(1, Any(Number))).toThrow("'Any' cannot have any arguments.")

		test "Any([]) type should throw an error", ->
			expect(-> isValid(1, Any([]))).toThrow("'Any' cannot have any arguments.")

	describe "Maybe type", ->

		test "maybe(Any) should not return Any type.", ->
			warnSpy.resetHistory()
			expect(maybe(Any)).to.eql([undefined, Any])
			expect(warnSpy.calledOnceWithExactly(
				"Any is not needed as 'maybe' argument."
			)).toBe(true)

		test "maybe(Any()) should not return Any type.", ->
			warnSpy.resetHistory()
			expect(maybe(Any())).to.eql([undefined, Any()])
			expect(warnSpy.calledOnceWithExactly(
				"Any is not needed as 'maybe' argument."
			)).toBe(true)

		test "maybe should throw an error when used as with more than 1 argument", ->
			expect(-> isValid(1, maybe(Number, String)))
			.toThrow("'maybe' must have exactly 1 argument.")

		test "maybe(undefined) should throw an error", ->
			expect(-> isValid(1, maybe(undefined)))
			.toThrow("'maybe' argument cannot be undefined.")

		test "return true when value is undefined.", ->
			expect(isValid(undefined, maybe(t))).toBe(true) for t in NATIVE_TYPES when t isnt undefined

		test "return true for a null type, false for other types.", ->
			expect(isValid(null, maybe(null))).toBe(true)
			expect(isValid(null, maybe(t))).toBe(false) for t in NATIVE_TYPES when t isnt undefined and t isnt null

		test "return true for a number type, false for other types.", ->
			expect(isValid(1.1, maybe(Number))).toBe(true)
			expect(isValid(1.1, maybe(t))).toBe(false) for t in NATIVE_TYPES when t isnt undefined and t isnt Number

		test "return true for a string type, false for other types.", ->
			expect(isValid("Énorme !", maybe(String))).toBe(true)
			expect(isValid("Énorme !", maybe(t))).toBe(false) for t in NATIVE_TYPES when t isnt undefined and t isnt String

		test "return true for a Number or a String or undefined, when union is used", ->
			expect(isValid(1, maybe([Number, String]))).toBe(true)
			expect(isValid('1', maybe([Number, String]))).toBe(true)
			expect(isValid(undefined, maybe([Number, String]))).toBe(true)

		test "maybe() should throw an error when type is ommited", ->
			expect(-> isValid(1, maybe()))
			.to.be.throw("'maybe' must have exactly 1 argument.")

		test "maybe should throw an error when used as a function", ->
			expect(-> isValid(1, maybe)).toThrow("'maybe' must have exactly 1 argument")

describe "Literal Types", ->

	test "return true when value is the same string as the type literal, false if different", ->
		expect(isValid("foo", "foo")).toBe(true)
		expect(isValid("Énorme !", "Énorme !")).toBe(true)
		expect(isValid('', '')).toBe(true)
		expect(isValid(' ', ' ')).toBe(true)
		expect(isValid("Foo", "foo")).toBe(false)
		expect(isValid("string", "foo")).toBe(false)
		expect(isValid("String", "foo")).toBe(false)
		expect(isValid(String, "String")).toBe(false)

	test "return true when value is the same number as the type literal, false if different", ->
		expect(isValid(1234, 1234)).toBe(true)
		expect(isValid(1234.56, 1234.56)).toBe(true)
		expect(isValid(-1, -1)).toBe(true)
		expect(isValid(1235, 1234)).toBe(false)
		expect(isValid(-1234, 1234)).toBe(false)
		expect(isValid(Number, 1234)).toBe(false)

	test "return true when value is the same boolean as the type literal, false if different", ->
		expect(isValid(true, true)).toBe(true)
		expect(isValid(false, true)).toBe(false)
		expect(isValid(false, false)).toBe(true)
		expect(isValid(true, false)).toBe(false)
		expect(isValid(Boolean, true)).toBe(false)
		expect(isValid(Boolean, false)).toBe(false)

describe "Native Types", ->

	test "return true for an undefined type, false for other types", ->
		testTypes(undefined, undefined)

	test "return true for a null type, false for other types", ->
		testTypes(null, null)

	test "return true for NaN type, false for other types", ->
		expect(isValid(NaN, NaN)).toBe(true)
		expect(isValid(NaN, Number)).toBe(false)
		expect(isValid(1, NaN)).toBe(false)
		testTypes(NaN, NaN)

	test "return true for Infinity type, false for other types", ->
		expect(isValid(Infinity, Infinity)).toBe(true)
		expect(isValid(Infinity, Number)).toBe(false)
		expect(isValid(1, Infinity)).toBe(false)
		testTypes(Infinity, Infinity)

	test "return true for -Infinity type, false for other types", ->
		expect(isValid(-Infinity, -Infinity)).toBe(true)
		expect(isValid(-Infinity, Number)).toBe(false)
		expect(isValid(-1, -Infinity)).toBe(false)
		testTypes(-Infinity, -Infinity)

	test "return true for a number type, false for other types", ->
		testTypes(1.1, Number)
		testTypes(0, Number)

	test "return true for a boolean type, false for other types", ->
		testTypes(true, Boolean)
		testTypes(false, Boolean)

	test "return true for a string type, false for other types", ->
		testTypes('', String)
		testTypes("Énorme !", String)

	test "return true for an array type, false for other types", ->
		testTypes([1, 'a'], Array)

	test "return true for a date type, false for other types", ->
		testTypes(new Date(), Date)

	test "return true for an object type, false for other types", ->
		testTypes({}, Object)
		testTypes({foo: 'bar'}, Object)

	test "return true for a set type, false for other types", ->
		testTypes(new Set([]), Set)
		testTypes(new Set([1, 2]), Set)

	test "return true for a promise type, false for other types", ->
		testTypes(new Promise(->), Promise)
		testTypes(new Promise((resolve, reject) -> resolve()), Promise)

	test "return true for a function type, false for other types", ->
		testTypes((->), Function)
		testTypes(((a)-> a + 1), Function)

	test "return true for a factory function value and function type, false for other types", ->
		testTypes(((foo) -> ((bar)-> foo + bar)), Function)
		testTypes(((foo) -> ((bar)-> new Promise((resolve, reject) -> resolve(foo + bar)))), Function)

describe "Object Types", ->

	test "return true if both value and type are empty object.", ->
		expect(isValid({}, {})).toBe(true)

	test "return false if type is empty object but value unempty object.", ->
		expect(isValid({a: 1}, {})).toBe(false)

	test "return false if value is empty object but type unempty object.", ->
		expect(isValid({}, {a: Number})).toBe(false)

	test "return true if same object type but one more key.", ->
		expect(isValid({a: 1, b: 2, c: 'foo'}, {a: Number, b: Number})).toBe(true)

	test "return false if same object type but one key less.", ->
		expect(isValid({a: 1}, {a: Number, b: Number})).toBe(false)

	test "return false for an object type and non object values", ->
		UserType =
			id: Number
			name: String
		expect(isValid(undefined, UserType)).toBe(false)
		expect(isValid(null, UserType)).toBe(false)
		expect(isValid(val, UserType)).toBe(false) \
			for val in VALUES when val isnt undefined and val isnt null and val.constructor isnt Object

	test "return true for a shallow object type, false otherwise", ->
		UserType =
			id: Number
			name: String
		expect(isValid({id: 1234, name: "Smith"}, UserType)).toBe(true)
		expect(isValid({id: 1234, name: "Smith", foo: "bar"}, UserType)).toBe(true)
		expect(isValid({foo: 1234, name: "Smith"}, UserType)).toBe(false)
		expect(isValid({id: '1234', name: "Smith"}, UserType)).toBe(false)
		expect(isValid({id: 1234, name: ["Smith"]}, UserType)).toBe(false)
		expect(isValid({name: "Smith"}, UserType)).toBe(false)
		expect(isValid({id: 1234}, UserType)).toBe(false)
		expect(isValid({}, UserType)).toBe(false)

	test "return true for a deep object type, false otherwise", ->
		UserType =
			id: Number
			name:
				firstName: String
				lastName: String
				middleName: [String, undefined]
		expect(isValid({id: 1234, name: {firstName: "John", lastName: "Smith", middleName: "Jack"}}, UserType))
		.toBe(true)
		expect(isValid({id: 1234, name: {firstName: "John", lastName: "Smith", middleName: 1}}, UserType))
		.toBe(false)
		expect(isValid({id: 1234, name: {firstName: "John", lastName: "Smith"}}, UserType)).toBe(true)
		expect(isValid({id: 1234}, UserType)).toBe(false)
		expect(isValid({name: {firstName: "John", lastName: "Smith"}}, UserType)).toBe(false)
		expect(isValid({id: 1234, name: {firstName: "John"}}, UserType)).toBe(false)
		expect(isValid({id: 1234, name: {firstName: "John", lostName: "Smith"}}, UserType)).toBe(false)
		expect(isValid({id: 1234, name: {firstName: "John", lastName: [1]}}, UserType)).toBe(false)
		expect(isValid({id: '1234', name: "Smith"}, UserType)).toBe(false)
		expect(isValid({id: 1234, name: ["Smith"]}, UserType)).toBe(false)

	test "return false for object type {name: 'Number'} and a number value", ->
		expect(isValid(1, {name: 'Number'})).toBe(false)

describe "Sized Array", ->

	test "return false for empty array", ->
		expect(isValid([], Array(1))).toBe(false)
		expect(isValid([], Array(2))).toBe(false)
		expect(isValid([], Array(3))).toBe(false)

	test "return true for same size array of undefined", ->
		expect(isValid([undefined], Array(1))).toBe(true)
		expect(isValid([undefined, undefined], Array(2))).toBe(true)
		expect(isValid([undefined, undefined, undefined], Array(3))).toBe(true)

	test "return true for same size array of anything", ->
		expect(isValid([1], Array(1))).toBe(true)
		expect(isValid([1, true], Array(2))).toBe(true)
		expect(isValid([undefined, true], Array(2))).toBe(true)
		expect(isValid([1, true, "three"], Array(3))).toBe(true)
		expect(isValid([1, true, "tree"], Array(3))).toBe(true)
		expect(isValid([undefined, true, "tree"], Array(3))).toBe(true)
		expect(isValid([1, undefined, "tree"], Array(3))).toBe(true)

	test "return false for different size array of anything", ->
		expect(isValid([1], Array(2))).toBe(false)
		expect(isValid([1, true], Array(3))).toBe(false)
		expect(isValid([1, 1], Array(3))).toBe(false)
		expect(isValid([undefined, true], Array(4))).toBe(false)
		expect(isValid([1, 1, 1], Array(4))).toBe(false)
		expect(isValid([1, true, "three"], Array(4))).toBe(false)
		expect(isValid([1, true, "tree"], Array(4))).toBe(false)
		expect(isValid([undefined, true, "tree"], Array(4))).toBe(false)
		expect(isValid([1, undefined, "tree"], Array(4))).toBe(false)

describe "Union Types", ->

	test "return true if the value is one of the given strings, false otherwise", ->
		expect(isValid("foo", ["foo", "bar"])).toBe(true)
		expect(isValid("bar", ["foo", "bar"])).toBe(true)
		expect(isValid("baz", ["foo", "bar"])).toBe(false)
		expect(isValid(Array, ["foo", "bar"])).toBe(false)

	test "return true if the value is one of the given strings, false otherwise", ->
		expect(isValid(1, [1, 2])).toBe(true)
		expect(isValid(2, [1, 2])).toBe(true)
		expect(isValid(3, [1, 2])).toBe(false)
		expect(isValid(Array, [1, 2])).toBe(false)

	test "return true for a string or a number value, false otherwise", ->
		expect(isValid("foo", [String, Number])).toBe(true)
		expect(isValid(1234, [String, Number])).toBe(true)
		expect(isValid(null, [String, Number])).toBe(false)
		expect(isValid({}, [String, Number])).toBe(false)
		expect(isValid(new Date(), [Object, Number])).toBe(false)

	test "return true for a string or null value, false otherwise", ->
		expect(isValid("foo", [String, null])).toBe(true)
		expect(isValid(null, [String, null])).toBe(true)
		expect(isValid(1234, [String, null])).toBe(false)

	test "return true for an object or null value, false otherwise", ->
		expect(isValid({id: 1234, name: "Smith"}, [Object, null])).toBe(true)
		expect(isValid(null, [Object, null])).toBe(true)
		expect(isValid("foo", [Object, null])).toBe(false)

	test "return true for an object type or null value, false otherwise", ->
		UserType =
			id: Number
			name: String
		expect(isValid({id: 1234, name: "Smith"}, [UserType, null])).toBe(true)
		expect(isValid(null, [UserType, null])).toBe(true)
		expect(isValid("foo", [UserType, null])).toBe(false)

describe "Custom types", ->

	test "throw an error when creating an instance of Type", ->
		expect(-> new Type()).toThrow("Abstract class 'Type' cannot be instantiated directly.")

	describe "Integer type", ->

		test "throw an error when Integer arguments are not numers", ->
			expect(-> isValid(1, Integer('100'))).toThrow("'Integer' arguments must be numbers.")
			expect(-> isValid(1, Integer(1, '100'))).toThrow("'Integer' arguments must be numbers.")
			expect(-> isValid(1, Integer('1', 100))).toThrow("'Integer' arguments must be numbers.")
			expect(-> isValid(1, Integer('1', '100'))).toThrow("'Integer' arguments must be numbers.")

		test "not throw an error when Integer is used as a function", ->
			expect(isValid(1, Integer)).toBe(true)

		test "not throw an error when Integer is used without arguments", ->
			expect(isValid(1, Integer())).toBe(true)

		test "return true for an integer number", ->
			expect(isValid(1, Integer)).toBe(true)
			expect(isValid(0, Integer)).toBe(true)
			expect(isValid(-0, Integer)).toBe(true)
			expect(isValid(-1, Integer)).toBe(true)

		test "return false for an decimal number", ->
			expect(isValid(1.1, Integer)).toBe(false)
			expect(isValid(0.1, Integer)).toBe(false)
			expect(isValid(-0.1, Integer)).toBe(false)
			expect(isValid(-1.1, Integer)).toBe(false)

	describe "Natural type", ->

		test "throw an error when Natural arguments are not numers", ->
			expect(-> isValid(1, Natural('100')))
			.toThrow("'Natural' arguments must be numbers.")

		test "throw an error when Natural arguments are negative", ->
			expect(-> isValid(1, Natural(-1)))
			.toThrow("'Natural' arguments must be positive numbers.")

		test "throw an error when Natural arguments are negative", ->
			expect(-> isValid(1, Natural(-100, -10)))
			.toThrow("'Natural' arguments must be positive numbers.")

		test "return false for an negative integer", ->
			expect(isValid(-1, Natural)).toBe(false)

		test "return true for an positive integer", ->
			expect(isValid(1, Natural)).toBe(true)

		test "return true for zero", ->
			expect(isValid(0, Natural)).toBe(true)
			expect(isValid(-0, Natural)).toBe(true)

	describe "SizedString type", ->

		test "throw an error when SizedString is used as a function", ->
			expect(-> isValid("123", SizedString)).toThrow("'SizedString' must have at least 1 argument.")

		test "throw an error when SizedString is used without arguments", ->
			expect(-> isValid("123", SizedString())).toThrow("'SizedString' must have at least 1 argument.")

		test "throw an error when SizedString arguments are not numers", ->
			expect(-> isValid("123", SizedString('100')))
			.toThrow("'SizedString' arguments must be positive integers.")

		test "throw an error when SizedString arguments are negative", ->
			expect(-> isValid("123", SizedString(-1)))
			.toThrow("'SizedString' arguments must be positive integers.")

		test "throw an error when SizedString arguments are negative", ->
			expect(-> isValid("123", SizedString(-100, -10)))
			.toThrow("'SizedString' arguments must be positive integers.")

		test "return false for a too long string", ->
			expect(isValid("123", SizedString(2))).toBe(false)

		test "return false for a too short string", ->
			expect(isValid("123", SizedString(4, 10))).toBe(false)

	describe "Tuple type", ->

		test "throw an error when Tuple is used as a function", ->
			expect(-> isValid(1, Tuple)).toThrow("'Tuple' must have at least 2 arguments.")

		test "throw an error when Tuple is used without arguments", ->
			expect(-> isValid(1, Tuple())).toThrow("'Tuple' must have at least 2 arguments.")

		describe "Any type elements", ->

			test "Tuple of Any should return array of empty elements", ->
				warnSpy.resetHistory()
				t = Tuple(Any, Any)
				expect(t.constructor.name).to.equal("Tuple")
				expect(t.types).to.eql([Any, Any])
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Array(2)' type instead of a Tuple of 2 values of any type'."
				)).toBe(true)

			test "Tuple of Any() should return array of empty elements", ->
				warnSpy.resetHistory()
				t = Tuple(Any(), Any())
				expect(t.constructor.name).to.equal("Tuple")
				expect(t.types).to.eql([Any(), Any()])
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Array(2)' type instead of a Tuple of 2 values of any type'."
				)).toBe(true)


		describe "Native type elements", ->

			test "return true when value is an array correspondig to Tuple type", ->
				expect(isValid([1, true, "three"], Tuple(Number, Boolean, String))).toBe(true)

			test "return false when value is an array not correspondig to Tuple type", ->
				expect(isValid(["1", true, "three"], Tuple(Number, Boolean, String))).toBe(false)

			test "return false when value is a number", ->
				expect(isValid(1, Tuple(Number, Boolean, String))).toBe(false)

			test "return false when value is an empty array", ->
				expect(isValid([], Tuple(Number, Boolean, String))).toBe(false)

	describe "Typed object", ->

		test "throw an error when TypedObject is used as a function", ->
			expect(-> isValid(1, TypedObject)).toThrow("'TypedObject' must have exactly 1 argument.")

		test "throw an error when TypedObject is used without arguments", ->
			expect(-> isValid(1, TypedObject())).toThrow("'TypedObject' must have exactly 1 argument.")

	describe "Typed array", ->

		describe "Native type elements", ->

			test "return false when value is not an array", ->
				expect(isValid(val, Array(Number))).toBe(false) for val in VALUES when not Array.isArray(val)
				expect(isValid(val, Array(String))).toBe(false) for val in VALUES when not Array.isArray(val)

			test "return true for an array of numbers", ->
				expect(isValid([1, 2, 3], Array(Number))).toBe(true)
				expect(isValid([1], Array(Number))).toBe(true)
				expect(isValid([], Array(Number))).toBe(true)

			test "return true for an array of strings", ->
				expect(isValid(["foo", "bar", "baz"], Array(String))).toBe(true)
				expect(isValid(["foo"], Array(String))).toBe(true)
				expect(isValid([], Array(String))).toBe(true)

			test "return false when an element of the array is not a number", ->
				expect(isValid([1, val, 3], Array(Number))).toBe(false) for val in VALUES when typeof val isnt 'number'
				expect(isValid([val], Array(Number))).toBe(false) for val in VALUES when typeof val isnt 'number'

			# TODO: test typed array optimizations

			test "return false when an element of the array is not a string", ->
				expect(isValid(["foo", val, "bar"], Array(String))).toBe(false) \
					for val in VALUES when typeof val isnt 'string'
				expect(isValid([val], Array(String))).toBe(false) \
					for val in VALUES when typeof val isnt 'string'

		describe "Object type elements", ->

			test "return false when value is not an array", ->
				nsType = {n: Number, s: String}
				expect(isValid(val, Array(nsType))).toBe(false) for val in VALUES when not Array.isArray(val)

			test "return true when all elements of the array are of a given object type", ->
				nsType = {n: Number, s: String}
				expect(isValid([{n: 1, s: "a"}, {n: 2, s: "b"}, {n: 3, s: "c"}], Array(nsType))).toBe(true)
				expect(isValid([{n: 1, s: "a"}], Array(nsType))).toBe(true)
				expect(isValid([], Array(nsType))).toBe(true)

			test "return false when some elements of the array are not of a given object type", ->
				nsType = {n: Number, s: String}
				expect(isValid([{n: 1, s: "a"}, val, {n: 3, s: "c"}], Array(nsType))).toBe(false) for val in VALUES
				expect(isValid([val], Array(nsType))).toBe(false) for val in VALUES
				expect(isValid([{n: 1, s: "a"}, {foo: 2, s: "b"}, {n: 3, s: "c"}], Array(nsType))).toBe(false)

		describe "Union type elements", ->

			test "return false when value is not an array", ->
				expect(isValid(val, Array([Number, String]))).toBe(false) for val in VALUES when not Array.isArray(val)

			test "return true for an array whom values are strings or numbers", ->
				expect(isValid([], Array([String, Number]))).toBe(true)
				expect(isValid(["foo", "bar", "baz"], Array([String, Number]))).toBe(true)
				expect(isValid(["foo"], Array([String, Number]))).toBe(true)
				expect(isValid([1, 2, 3], Array([String, Number]))).toBe(true)
				expect(isValid([1], Array([String, Number]))).toBe(true)
				expect(isValid(["foo", 1, "bar"], Array([String, Number]))).toBe(true)
				expect(isValid([1, "foo", 2], Array([String, Number]))).toBe(true)

			test "return false when an element of the array is not a string nor a number", ->
				expect(isValid(["foo", val, 1], Array([String, Number]))).toBe(false) \
					for val in VALUES when typeof val isnt 'string' and typeof val isnt 'number'
				expect(isValid([val], Array([String, Number]))).toBe(false) \
					for val in VALUES when typeof val isnt 'string' and typeof val isnt 'number'

	describe "Typed set", ->

		describe "Literal type elements", ->

			test "throw an error when type is literal", ->
				expect(-> TypedSet(1)).toThrow("You cannot have literal Number 1 as 'TypedSet' argument.")
				expect(-> TypedSet(undefined)).toThrow("You cannot have undefined as 'TypedSet' argument.")
				expect(-> TypedSet(null)).toThrow("You cannot have null as 'TypedSet' argument.")

		describe "Any type elements", ->

			test "TypedSet() should throw an error", ->
				expect(-> TypedSet()).toThrow("'TypedSet' must have exactly 1 argument.")

			test "TypedSet used as a function should throw an error.", ->
				expect(-> isValid(1, TypedSet)).toThrow("'TypedSet' must have exactly 1 argument.")

			test "TypedSet(Any) should return a TypedSet instance and log a warning.", ->
				warnSpy.resetHistory()
				t = TypedSet(Any)
				expect(t.constructor.name).to.equal("TypedSet")
				expect(t.type).to.eql(Any)
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Set' type instead of a TypedSet with elements of any type."
				)).toBe(true)

			test "TypedSet(Any()) should return a TypedSet instance and log a warning.", ->
				warnSpy.resetHistory()
				t = TypedSet(Any())
				expect(t.constructor.name).to.equal("TypedSet")
				expect(t.type).to.eql(Any())
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Set' type instead of a TypedSet with elements of any type."
				)).toBe(true)

		describe "Native type elements", ->

			test "return false when value is not a set", ->
				expect(isValid(val, TypedSet(Number))).toBe(false) for val in VALUES when not val?.constructor is Set
				expect(isValid(val, TypedSet(String))).toBe(false) for val in VALUES when not val?.constructor is Set

			test "return true for a set of numbers", ->
				expect(isValid(new Set([1, 2, 3]), TypedSet(Number))).toBe(true)
				expect(isValid(new Set([1]), TypedSet(Number))).toBe(true)
				expect(isValid(new Set([]), TypedSet(Number))).toBe(true)

			test "return true for a set of strings", ->
				expect(isValid(new Set(["foo", "bar", "baz"]), TypedSet(String))).toBe(true)
				expect(isValid(new Set(["foo"]), TypedSet(String))).toBe(true)
				expect(isValid(new Set([]), TypedSet(String))).toBe(true)

			test "return false when an element of the set is not a number", ->
				expect(isValid(new Set([1, val, 3]), TypedSet(Number))).toBe(false) for val in VALUES when typeof val isnt 'number'
				expect(isValid(new Set([val]), TypedSet(Number))).toBe(false) for val in VALUES when typeof val isnt 'number'

			test "return false when an element of the set is not a string", ->
				expect(isValid(new Set(["foo", val, "bar"]), TypedSet(String))).toBe(false) \
					for val in VALUES when typeof val isnt 'string'
				expect(isValid(new Set([val]), TypedSet(String))).toBe(false) \
					for val in VALUES when typeof val isnt 'string'

		describe "Object type elements", ->

			test "return false when value is not a set", ->
				nsType = {n: Number, s: String}
				expect(isValid(val, TypedSet(nsType))).toBe(false) for val in VALUES when not val?.constructor is Set

			test "return true when all elements of the set are of a given object type", ->
				nsType = {n: Number, s: String}
				expect(isValid(new Set([{n: 1, s: "a"}, {n: 2, s: "b"}, {n: 3, s: "c"}]), TypedSet(nsType))).toBe(true)
				expect(isValid(new Set([{n: 1, s: "a"}]), TypedSet(nsType))).toBe(true)
				expect(isValid(new Set([]), TypedSet(nsType))).toBe(true)

			test "return false when some elements of the set are not of a given object type", ->
				nsType = {n: Number, s: String}
				expect(isValid(new Set([{n: 1, s: "a"}, val, {n: 3, s: "c"}]), TypedSet(nsType))).toBe(false) for val in VALUES
				expect(isValid(new Set([val]), TypedSet(nsType))).toBe(false) for val in VALUES
				expect(isValid(new Set([{n: 1, s: "a"}, {foo: 2, s: "b"}, {n: 3, s: "c"}]), TypedSet(nsType))).toBe(false)

		describe "Union type elements", ->

			test "return false when value is not a set", ->
				expect(isValid(val, TypedSet([Number, String]))).toBe(false) for val in VALUES when not val?.constructor is Set

			test "return true for a set whom values are strings or numbers", ->
				expect(isValid(new Set([]), TypedSet([String, Number]))).toBe(true)
				expect(isValid(new Set(["foo", "bar", "baz"]), TypedSet([String, Number]))).toBe(true)
				expect(isValid(new Set(["foo"]), TypedSet([String, Number]))).toBe(true)
				expect(isValid(new Set([1, 2, 3]), TypedSet([String, Number]))).toBe(true)
				expect(isValid(new Set([1]), TypedSet([String, Number]))).toBe(true)
				expect(isValid(new Set(["foo", 1, "bar"]), TypedSet([String, Number]))).toBe(true)
				expect(isValid(new Set([1, "foo", 2]), TypedSet([String, Number]))).toBe(true)

			test "return false when an element of the set is not a string nor a number", ->
				expect(isValid(new Set(["foo", val, 1]), TypedSet([String, Number]))).toBe(false) \
					for val in VALUES when typeof val isnt 'string' and typeof val isnt 'number'
				expect(isValid(new Set([val]), TypedSet([String, Number]))).toBe(false) \
					for val in VALUES when typeof val isnt 'string' and typeof val isnt 'number'

	describe "Typed map", ->

		describe "Literal type elements", ->

			test "throw an error when literals for both keys and values types", ->
				expect(-> TypedMap("foo", 1))
				.toThrow("You cannot have both literal String \"foo\" as keys type
							and literal Number 1 as values type in a TypedMap.")
				expect(-> TypedMap(null, undefined))
				.toThrow("You cannot have both null as keys type and undefined as values type in a TypedMap.")
				expect(-> TypedMap(undefined, undefined))
				.toThrow("You cannot have both undefined as keys type and undefined as values type in a TypedMap.")

		describe "Any type elements", ->

			test "TypedMap() should throw an error.", ->
				expect(-> TypedMap()).toThrow("'TypedMap' must have at least 1 argument.")

			test "TypedMap used as a function should throw an error.", ->
				expect(-> isValid(1, TypedMap)).toThrow("'TypedMap' must have at least 1 argument.")

			test "TypedMap(Any) should return a TypedMap instance and log a warning.", ->
				warnSpy.resetHistory()
				t = TypedMap(Any)
				expect(t.constructor.name).to.equal("TypedMap")
				expect(t.valuesType).to.eql(Any)
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Map' type instead of a TypedMap with values of any type."
				)).toBe(true)

			test "TypedMap(Any, Any) should return a TypedMap instance and log a warning.", ->
				warnSpy.resetHistory()
				t = TypedMap(Any, Any)
				expect(t.constructor.name).to.equal("TypedMap")
				expect([t.valuesType, t.keysType]).to.eql([Any, Any])
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Map' type instead of a TypedMap with keys and values of any type."
				)).toBe(true)

			test "TypedMap(Any()) should return a TypedMap instance and log a warning.", ->
				warnSpy.resetHistory()
				t = TypedMap(Any())
				expect(t.constructor.name).to.equal("TypedMap")
				expect(t.valuesType).to.eql(Any())
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Map' type instead of a TypedMap with values of any type."
				)).toBe(true)

			test "TypedMap(Any(), Any()) should return a TypedMap instance and log a warning.", ->
				warnSpy.resetHistory()
				t = TypedMap(Any(), Any())
				expect(t.constructor.name).to.equal("TypedMap")
				expect([t.valuesType, t.keysType]).to.eql([Any(), Any()])
				expect(warnSpy.calledOnceWithExactly(
					"Use 'Map' type instead of a TypedMap with keys and values of any type."
				)).toBe(true)

		describe "Native type elements", ->

			test "return false when value is not a Map", ->
				expect(isValid(val, TypedMap(Number))).toBe(false) for val in VALUES when not val?.constructor is Map
				expect(isValid(val, TypedMap(String))).toBe(false) for val in VALUES when not val?.constructor is Map
				expect(isValid(val, TypedMap(Number, String))).toBe(false) for val in VALUES when not val?.constructor is Map
				expect(isValid(val, TypedMap(String, Number))).toBe(false) for val in VALUES when not val?.constructor is Map

			test "return true for a Map of numbers", ->
				expect(isValid(new Map([['one', 1], ['two', 2], ['three', 3]]), TypedMap(Number))).toBe(true)
				expect(isValid(new Map([['one', 1]]), TypedMap(Number))).toBe(true)
				expect(isValid(new Map([]), TypedMap(Number))).toBe(true)

			test "return true for a Map of strings -> numbers", ->
				expect(isValid(new Map([['one', 1], ['two', 2], ['three', 3]]), TypedMap(String, Number))).toBe(true)
				expect(isValid(new Map([['one', 1]]), TypedMap(String, Number))).toBe(true)
				expect(isValid(new Map([]), TypedMap(String, Number))).toBe(true)

			test "return true for a Map of strings", ->
				expect(isValid(new Map([[1, 'one'], [2, 'two'], [3, 'three']]), TypedMap(String))).toBe(true)
				expect(isValid(new Map([[1, 'one']]), TypedMap(String))).toBe(true)
				expect(isValid(new Map([]), TypedMap(String))).toBe(true)

			test "return true for a Map of numbers -> strings", ->
				expect(isValid(new Map([[1, 'one'], [2, 'two'], [3, 'three']]), TypedMap(Number, String))).toBe(true)
				expect(isValid(new Map([[1, 'one']]), TypedMap(Number, String))).toBe(true)
				expect(isValid(new Map([]), TypedMap(Number, String))).toBe(true)

			test "return false when an element of the Map is not a number", ->
				expect(isValid(new Map([['one', 1], ['two', val], ['three', 3]]), TypedMap(Number)))
				.toBe(false) for val in VALUES when typeof val isnt 'number'
				expect(isValid(new Map([['foo', val]]), TypedMap(Number)))
				.toBe(false) for val in VALUES when typeof val isnt 'number'

			test "return false when an element of the Map is not a string", ->
				expect(isValid(new Map([[1, 'one'], [2, val], [3, 'three']]), TypedMap(String)))
				.toBe(false) for val in VALUES when typeof val isnt 'string'
				expect(isValid(new Map([[1234, val]]), TypedMap(String)))
				.toBe(false) for val in VALUES when typeof val isnt 'string'

			test "return false when a value of the Map number -> string is not a string", ->
				expect(isValid(new Map([[1, 'one'], [2, val], [3, 'three']]), TypedMap(Number, String)))
				.toBe(false) for val in VALUES when typeof val isnt 'string'
				expect(isValid(new Map([[1234, val]]), TypedMap(Number, String)))
				.toBe(false) for val in VALUES when typeof val isnt 'string'

			test "return false when a key of the Map number -> string is not a string", ->
				expect(isValid(new Map([[1, 'one'], [val, 'two'], [3, 'three']]), TypedMap(Number, String)))
				.toBe(false) for val in VALUES when typeof val isnt 'number'
				expect(isValid(new Map([[val, 'foo']]), TypedMap(Number, String)))
				.toBe(false) for val in VALUES when typeof val isnt 'number'

		describe "Object type elements", ->

			test "return false when value is not a Map", ->
				nsType = {n: Number, s: String}
				expect(isValid(val, TypedMap(nsType))).toBe(false) for val in VALUES when not val?.constructor is Map

			test "return true when all elements of the Map are of a given object type", ->
				nsType = {n: Number, s: String}
				m = new Map([[1, {n: 1, s: "a"}], [2, {n: 2, s: "b"}], [3, {n: 3, s: "c"}]])
				expect(isValid(m, TypedMap(nsType))).toBe(true)
				expect(isValid(new Map([[1, {n: 1, s: "a"}]]), TypedMap(nsType))).toBe(true)
				expect(isValid(new Map([]), TypedMap(nsType))).toBe(true)

			test "return false when some elements of the Map are not of a given object type", ->
				nsType = {n: Number, s: String}
				expect(isValid(new Map([[1, {n: 1, s: "a"}], [2, val], [3, {n: 3, s: "c"}]]),
								TypedMap(nsType))).toBe(false) for val in VALUES
				expect(isValid(new Map([[1, val]]), TypedMap(nsType))).toBe(false) for val in VALUES
				expect(isValid(new Map([[1, {n: 1, s: "a"}], [2, {foo: 2, s: "b"}], [3, {n: 3, s: "c"}]]),
								TypedMap(nsType))).toBe(false)

		describe "Union type elements", ->

			test "return false when value is not a Map", ->
				expect(isValid(val, TypedMap([Number, String]))).toBe(false) for val in VALUES when not val?.constructor is Map

			test "return true for a Map whom values are strings or numbers", ->
				expect(isValid(new Map([]), TypedMap([String, Number]))).toBe(true)
				expect(isValid(new Map([[1, "foo"], [2, "bar"], [3, "baz"]]), TypedMap([String, Number]))).toBe(true)
				expect(isValid(new Map([[1, "foo"]]), TypedMap([String, Number]))).toBe(true)
				expect(isValid(new Map([[1, 1], [2, 2], [3, 3]]), TypedMap([String, Number]))).toBe(true)
				expect(isValid(new Map([[1, 1]]), TypedMap([String, Number]))).toBe(true)
				expect(isValid(new Map([[1, "foo"], [2, 1], [3, "bar"]]), TypedMap([String, Number]))).toBe(true)
				expect(isValid(new Map([[1, "foo"], [2, 2]]), TypedMap([String, Number]))).toBe(true)

			test "return false when an element of the Map is not a string nor a number", ->
				expect(isValid(new Map([[1, "foo"], [2, val], [3, 1]]), TypedMap([String, Number]))).toBe(false) \
					for val in VALUES when typeof val isnt 'string' and typeof val isnt 'number'
				expect(isValid(new Map([[1, val]]), TypedMap([String, Number]))).toBe(false) \
					for val in VALUES when typeof val isnt 'string' and typeof val isnt 'number'

describe "Foreign Type", ->

	test "return true when value is an instance of the foreign constructor", ->
		class Foo extends String
		foo = new Foo('foo')
		expect(isValid(foo, foreign('Foo'))).toBe(true)

	test "return false when value is not an instance of the foreign constructor", ->
		class Foo extends String
		foo = new Foo('foo')
		expect(isValid(foo, foreign('Bar'))).toBe(false)
		expect(isValid('baz', foreign('Foo'))).toBe(false)

	test "return true when value has the same property types", ->
		class Foo extends String
			bar: true
			baz: 0
		foo = new Foo('foo')
		expect(isValid(foo, foreign({bar: Boolean}))).toBe(true)
		expect(isValid(foo, foreign({bar: Boolean, baz: Number}))).toBe(true)
		expect(isValid(foo, foreign({bar: Boolean, baz: Number, boo: undefined}))).toBe(true)

	test "return false when value has not the same property types", ->
		class Foo extends String
			bar: true
			baz: 0
		foo = new Foo('foo')
		expect(isValid(foo, foreign({bar: Boolean, baz: String}))).toBe(false)
		expect(isValid(foo, foreign({bar: Boolean, baz: Number, boo: String}))).toBe(false)
		expect(isValid(foo, foreign({bar: Boolean, baz: Number, boo: String}))).toBe(false)

describe "Promised type", ->

	test "throw an error for a promised number.", ->
		expect(-> isValid(Promise.resolve(1), Promise.resolve(Number)))
		.toThrow("Type can not be an instance of Promise. Use Promise as type instead.")
		expect(-> isValid(Promise.resolve(1), promised(Number)))
		.toThrow("Type can not be an instance of Promise. Use Promise as type instead.")

describe "Custom type (class)", ->

	test "return true when type is MyClass, false for other types", ->
		class MyClass
		mc = new MyClass
		testTypes(mc, MyClass)

describe "Unmanaged Types", ->

	test "throw an error when etc is used as a function", ->
		expect(-> isValid(1, etc))
		.toThrow("'etc' cannot be used in types.")

	test "throw an error when etc is used without parameter", ->
		expect(-> isValid(1, etc()))
		.toThrow("'etc' cannot be used in types.")

	test "throw an error when type is not a native type nor an object nor an array of types
		nor a string or number or boolean literal.", ->
		expect(-> isValid(val, Symbol("foo")))
		.toThrow("Type can not be an instance of Symbol. Use Symbol as type instead.") for val in VALUES

describe "Logical operators", ->

	describe "And", ->

		test "And with a single value should throw an error", ->
			expect(-> And(1)).toThrow("'and' must have at least 2 arguments.")

		test "And with Any values should return an And instance and log a warning.", ->
			warnSpy.resetHistory()
			t = And(Number, Any)
			expect(t.constructor.name).to.equal("And")
			expect(t.types).to.eql([Number, Any])
			expect(warnSpy.calledOnceWithExactly(
				"Any is not needed as 'and' argument number 2."
			)).toBe(true)

		test "And with undefined value should throw an error.", ->
			expect(-> And(Number, undefined)).toThrow("You cannot have undefined as 'and' argument number 2.")
			expect(-> And(undefined, Number)).toThrow("You cannot have undefined as 'and' argument number 1.")

		test "And with null value should throw an error.", ->
			expect(-> And(Number, null)).toThrow("You cannot have null as 'and' argument number 2.")
			expect(-> And(null, Number)).toThrow("You cannot have null as 'and' argument number 1.")

		test "And with literal value should throw an error.", ->
			expect(-> And(Number, 1))
			.toThrow("You cannot have literal Number 1 as 'and' argument number 2.")
			expect(-> And("foo", Number))
			.toThrow("You cannot have literal String \"foo\" as 'and' argument number 1.")

		test "And with literal values should throw an error.", ->
			expect(-> And(undefined, null, 1, "foo", true, NaN))
			.toThrow("You cannot have undefined as 'and' argument number 1.")

		test "isValid with and() should return true only if value in intersection of array types", ->
			t = And(Array(Number), Array(2))
			expect(isValid([1, 2], t)).toBe(true)
			expect(isValid([1], t)).toBe(false)
			expect(isValid([1, "two"], t)).toBe(false)

		test "isValid with and() should return true only if value in intersection of unions of literal types", ->
			t = And(["foo", "bar"], ["bar", "baz"])
			expect(isValid("bar", t)).toBe(true)
			expect(isValid("foo", t)).toBe(false)
			expect(isValid("baz", t)).toBe(false)

	describe "Or", ->

		test "Or with a single value should throw an error", ->
			expect(-> Or(1)).toThrow("'or' must have at least 2 arguments.")

		test "Or with Any values should return an array and log a warning.", ->
			warnSpy.resetHistory()
			t = Or(Number, Any)
			expect(t).to.eql([Number, Any])
			expect(warnSpy.calledOnceWithExactly(
				"Any is inadequate as 'or' argument number 2."
			)).toBe(true)

	describe "Not", ->

		test "Not with more than a single value should throw an error", ->
			expect(-> Not(1, 2)).toThrow("'not' must have exactly 1 argument.")

		test "Not with Any value should return a Not instance and log a warning.", ->
			warnSpy.resetHistory()
			t = Not(Any)
			expect(t.constructor.name).to.equal("Not")
			expect(t.type).to.eql(Any)
			expect(warnSpy.calledOnceWithExactly(
				"Any is inadequate as 'not' argument."
			)).toBe(true)

		test "isValid with not() should return true only if value is not of the given type", ->
			t = Not([String, Number])
			expect(isValid("foo", t)).toBe(false)
			expect(isValid(1, t)).toBe(false)
			expect(isValid(true, t)).toBe(true)
			expect(isValid(false, t)).toBe(true)
			expect(isValid(NaN, t)).toBe(true)

describe "Regular expressions", ->

	test "return true only for a regular expression value when type is RegExp", ->
		expect(isValid(/foo/, RegExp)).toBe(true)
		expect(isValid("foo", RegExp)).toBe(false)

	test "test the value when type is a regular expression instance", ->
		expect(isValid("foo", /foo/)).toBe(true)
		expect(isValid("bar", /foo/)).toBe(false)
		expect(isValid("", /foo/)).toBe(false)
		expect(isValid(/foo/, /foo/)).toBe(false)
		expect(isValid(1, /foo/)).toBe(false)

describe "Constraint", ->

	test "return true when validator function is truthy for the value", ->
		Int = constraint((val) -> Number.isInteger(val))
		expect(isValid(100, Int)).toBe(true)
		expect(isValid(-10, Int)).toBe(true)
		expect(isValid(0, Int)).toBe(true)
		expect(isValid(val, Int)).toBe(false) for val in VALUES when not Number.isInteger(val)
