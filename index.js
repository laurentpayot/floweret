(function(){var e,t,n,r,u,a,s,o,c,i,y,l,f,p,d,h;u=function(e){throw new Error(function(){switch(e[0]){case"!":return`Invalid type syntax: ${e.slice(1)}`;case"@":return`Invalid signature: ${e.slice(1)}`;default:return`Type error: ${e}`}}())},t=class{constructor(e){if(this.type=e,1!==arguments.length&&u("!typedObject must have exactly one type argument."),s(this.type))return Object}},n=class{constructor(e){if(this.type=e,1!==arguments.length&&u("!typedSet must have exactly one type argument."),s(this.type))return Set}},e=function(){class e{constructor(e,t){switch(arguments.length){case 0:u("!typedMap must have at least one type argument.");break;case 1:if(s(e))return Map;this.valuesType=e;break;case 2:if(s(e)&&s(t))return Map;[this.keysType,this.valuesType]=[e,t];break;default:u("!typedMap can not have more than two type arguments.")}}}return e.prototype.keysType=[],e.prototype.valuesType=[],e}.call(this),s=function(e){return e===r||Array.isArray(e)&&0===e.length},r=function(){return arguments.length?u("!'anyType' can not have a type argument."):[]},c=function(...e){return arguments.length||u("!'maybe' must have at least one type argument."),e.some(function(e){return s(e)})?[]:[void 0,null].concat(e)},i=function(e){return 1!==arguments.length&&u("!'promised' must have exactly one type argument."),s(e)?Promise:Promise.resolve(e)},a=function(e){switch(arguments.length){case 0:return a;case 1:return function(){return e};default:return u("!'etc' can not have more than one type argument.")}},d=function(...e){return new t(...e)},h=function(...e){return new n(...e)},p=function(...t){return new e(...t)},f=function(e){return void 0===e||null===e?""+e:e.constructor.name},o=function(e,t){var n,y,l,m,v,g,b,$,T,w;switch(f(t)){case"undefined":case"null":case"String":case"Number":case"Boolean":return e===t;case"Function":switch(t){case r:return!0;case i:case c:case d:case h:case p:return u(`!'${t.name}' can not be used directly as a function.`);case a:return u("!'etc' can not be used in types.");default:return(null!=e?e.constructor:void 0)===t}break;case"Array":switch(t.length){case 0:return!0;case 1:return!!Array.isArray(e)&&(!!s(t[0])||e.every(function(e){return o(e,t[0])}));default:return t.some(function(t){return o(e,t)})}break;case"Object":if((null!=e?e.constructor:void 0)!==Object)return!1;if(!Object.keys(t).length)return!Object.keys(e).length;for(n in t)if($=t[n],!o(e[n],$))return!1;return!0;case"TypedObject":return(null!=e?e.constructor:void 0)===Object&&(b=t.type,!!s(b)||Object.values(e).every(function(e){return o(e,b)}));case"TypedSet":return(null!=e?e.constructor:void 0)===Set&&(b=t.type,!!s(b)||("undefined"!==(v=f(b))&&"null"!==v&&"String"!==v&&"Number"!==v&&"Boolean"!==v||u(`!Typed Set type can not be a literal of type '${b}'.`),[...e].every(function(e){return o(e,b)})));case"TypedMap":if((null!=e?e.constructor:void 0)!==Map)return!1;switch(({keysType:l,valuesType:w}=t),!1){case!(s(l)&&s(w)):return!0;case!s(l):return Array.from(e.values()).every(function(e){return o(e,w)});case!s(w):return Array.from(e.keys()).every(function(e){return o(e,l)});default:return y=Array.from(e.keys()),T=Array.from(e.values()),y.every(function(e){return o(e,l)})&&T.every(function(e){return o(e,w)})}break;default:return m="Set"===(g=f(t))||"Map"===g?"the provided Typed":"",u(`!Type can not be an instance of ${f(t)}. Use ${m}${f(t)} as type instead.`)}},l=function(e){var t;switch(f(e)){case"Array":return 1===e.length?`array of ${l(e[0])}`:function(){var n,r,u;for(u=[],n=0,r=e.length;n<r;n++)t=e[n],u.push(l(t));return u}().join(" or ");case"Function":return e.name;case"Object":return"custom type";default:return f(e)}},y=function(e,t,n){return Array.isArray(e)||u("@Array of arguments types is missing."),(null!=t?t.constructor:void 0)!==Function||t.name||u("@Result type is missing."),(null!=n?n.constructor:void 0)!==Function&&u("@Function to wrap is missing."),function(...r){var c,i,y,p,d,h,m,v,g,b,$,T;for(g=!1,i=p=0,d=e.length;p<d;i=++p)if("function"!=typeof(T=e[i])||"_etc"!==T.name&&T!==a)s(T)||(void 0===r[i]?o(void 0,T)||u(`Missing required argument number ${i+1}.`):o(r[i],T)||u(`Argument number ${i+1} (${r[i]}) should be of type ${l(T)} instead of ${f(r[i])}.`));else if(i+1<e.length&&u("@Rest type must be the last of the arguments types."),g=!0,$=T(),T!==a&&!s($))for(y=m=0,h=(v=r.slice(i)).length;m<h;y=++m)c=v[y],o(c,$)||u(`Argument number ${i+y+1} (${c}) should be of type ${l(T())} instead of ${f(c)}.`);return r.length>e.length&&!g&&u("Too many arguments provided."),o(t,Promise)?t.then(function(e){var t;return t=n(...r),o(t,Promise)||u("Function should return a promise."),t.then(function(t){return o(t,e)||u(`Promise result (${t}) should be of type ${l(e)} instead of ${f(t)}.`),t})}):(b=n(...r),o(b,t)||u(`Result (${b}) should be of type ${l(t)} instead of ${f(b)}.`),b)}},module.exports={typeOf:f,isType:o,sig:y,maybe:c,anyType:r,promised:i,etc:a,typedObject:d,typedSet:h,typedMap:p}}).call(this);