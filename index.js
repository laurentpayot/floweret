// Generated by CoffeeScript 2.3.1
(function() {
  // shortcut to `[<type>, undefined, null]`
  var isType, maybe, promised, sig, typeName, typeOf;

  maybe = function(t) {
    return [
      void 0,
      null,
      t // checking undefined and null types first
    ];
  };

  
  // shortcut to Promise.resolve
  promised = function(t) {
    return Promise.resolve(t);
  };

  // typeOf([]) is 'Array', whereas typeof [] is 'object'. Same for Promise etc.
  typeOf = function(val) {
    return Object.prototype.toString.call(val).slice(8, -1);
  };

  // check that a value is of a given type or of any (undefined) type, e.g.: isType("foo", String)
  isType = function(val, type) {
    var k, v;
    switch (false) {
      case type !== void 0:
        return val === void 0;
      case type !== null:
        return val === null;
      case !Array.isArray(type):
        switch (type.length) {
          case 0:
            return true; // any type: `[]`
          case 1: // typed array type, e.g.: `Array(String)`
            if (!Array.isArray(val)) {
              return false;
            } else {
              return val.every(function(v) {
                return isType(v, type[0]);
              });
            }
            break;
          default:
            return type.some(function(t) {
              return isType(val, t);
            });
        }
        break;
      // native type: Number, String, Object, Array (untyped), Promise etcâ€¦
      case typeof type !== 'function':
        return typeOf(val) === type.name;
      // custom type, e.g.: `{id: Number, name: {firstName: String, lastName: String}}`
      case typeof type !== 'object':
        if (!Object.keys(type).length) {
          throw new Error("Type can not be an empty object.");
        }
        if (typeOf(val) !== 'Object') {
          return false;
        }
        for (k in type) {
          v = type[k];
          if (!isType(val[k], v)) {
            return false;
          }
        }
        return true; // type is not a class but an instance
      default:
        throw new Error(`Type can not be '${type}'. Use ${typeOf(type)} class instead.`);
    }
  };

  // not exported: get type name for sig error messages (supposing type is always correct)
  typeName = function(type) {
    var t;
    switch (false) {
      case !Array.isArray(type):
        if (type.length === 1) {
          return `array of ${typeName(type[0])}.`;
        } else {
          return ((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = type.length; j < len; j++) {
              t = type[j];
              results.push(typeName(t));
            }
            return results;
          })()).join(" or ");
        }
        break;
      case typeof type !== 'function':
        return type.name;
      case !isType(type, Object):
        return "custom type";
      default:
        return typeOf(type);
    }
  };

  // wraps a function to check its arguments types and result type
  sig = function(argTypes, resType, f) {
    return function() {      // returns a function, sadly anonymous
      var i, j, len, result, type;
      if (!(arguments.length <= argTypes.length)) {
        throw new Error("Too many arguments provided.");
      }
      for (i = j = 0, len = argTypes.length; j < len; i = ++j) {
        type = argTypes[i];
        if (!(Array.isArray(type) && !type.length)) { // not checking type if any type
          if (arguments[i] === void 0) {
            if (!isType(void 0, type)) {
              throw new Error(`Missing required argument number ${i + 1}.`);
            }
          } else {
            if (!isType(arguments[i], type)) {
              throw new Error(`Argument number ${i + 1} (${arguments[i]}) should be of type ${typeName(type)} instead of ${typeOf(arguments[i])}.`);
            }
          }
        }
      }
      if (isType(resType, Promise)) {
        // NB: not using `await` because CS would transpile the returned function (of the factory) as an async one!!!
        return resType.then(function(promiseType) {
          var promise;
          promise = f(...arguments);
          if (!isType(promise, Promise)) {
            throw new Error("Function should return a promise.");
          }
          return promise.then(function(result) {
            if (!isType(result, promiseType)) {
              throw new Error(`Promise result (${result}) should be of type ${typeName(promiseType)} instead of ${typeOf(result)}.`);
            }
            return result;
          });
        });
      } else {
        result = f(...arguments);
        if (!isType(result, resType)) {
          throw new Error(`Result (${result}) should be of type ${typeName(resType)} instead of ${typeOf(result)}.`);
        }
        return result;
      }
    };
  };

  module.exports = {typeOf, isType, sig, maybe, promised};

}).call(this);
